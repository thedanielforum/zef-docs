---
id: 'rfz-clone-merge'
title: RFZ - Clone and Merge
---

We need a clearer and better distincition and tools for identity and lineage management.

### Merge
`merge(my_zrs, g)`  check whether RAEs of the same lineage already exist. If not, create one and track the lineage.
This generally preserves lineage, i.e. RAEs of the same lineage refer to the identical thing in the real world. In general, at anyy given time slice within one graph, only a single RAE of a given lineage may be alive. 

Multiple RAEs of the same lineage may exist on the same graph if an original RAE *z1* was terminated at some point on the local graph and a RAE of the same lineage is merged into the graph from another graph where this was not terminated yet. Hence, to satisfy all requierements of uid uniqueness for dicitionary lookup on the eternal graph, RAEs of the same lineage have different uids.

### Clone
`clone(my_zrs, g)`  It doesn't matter whether RAEs of the same lineage or other clones already exist. Definitely instantiate a new RAE with of the same type, which will have a separate identity and separate lineage. It will be merked on the graph where it was cloned from. Use cloning when the RAE refers to a different thing in the real world.

### Reverting Transactions
`revert(some_tx)` Conceptually identical to git merge. We want to undo all changes in some transaction, but not by mutating the graph, but accreting information in a new tx that exactly counteracts the changes in the tx that we want to undo within the time slice after the revert. If RAEs were terminated in *some_tx*, create new ones of the same lineage and connect them up in the same way as they were that the affected subgraph ('state') in the time slice prior to *some_tx* is isomorphic to the respective subgraph after the revert.



