---
id: zef-ops
title: ZefOps
author: bot
---

Autogenerated for version 0.15.6.post1.

### ApplyFunctions

```python
Apply different functions to different elements in a list.
The use case is similar to using Zef's map[f1,f2,f3] with multiple
functions, but fills in the gap when the input is not a list / stream.
In this sense, it is closer to func.
The input list and list of functions must be of the same length.

---- Examples ----
['Hello', 'World'] | apply_functions[to_upper_case, to_lower_case]    # => ['HELLO', 'world']

---- Signature ----
(Tuple[T1, ...,TN], Tuple[T1->TT1, ..., TN->TTN] ) -> Tuple[TT1, ...,TTN]

---- Tags ----
- used for: control flow
- operates on: ZefOps, Functions
- related zefop: func
- related zefop: reverse_args
- related zefop: map
```

### Map

```python
Apply a pure function elementwise to each item of a collection.
It can be used both for iterables and streams (observables).

Note: It is strongly recommended not to use impure functions
(with side effects, i.e. that change any state of the program)
inside "map". You may be looking for "for_each" or "tap" in that
case.

---- Examples -----
>>> [3, 4, 5] | map[add[1]]                      # => [4, 5, 6]
>>> [1, 2, 3] | map[str, add[100]]               # => [('1', 101), ('2', 102), ('3', 103)]

---- Signature ----
(List[T1], (T1 -> T2))  -> List[T2]

---- Tags ----
- used for: control flow
- used for: function application
- related zefop: apply_functions
```

### MapCat

```python
Returns the flatten results of f applied to each item of x. Equivalent to:
`x | map[f] | concat`.

---- Examples ----
>>> [1,0,3] | flat_map[lambda x: x | repeat[x]]  # => [1, 3, 3, 3]
>>> [z1,z2] | flat_map[Outs[RT]]             # All outgoing relations on z1 and z2.

---- Signature ----
(Iterable, Function) => List
```

### Reduce

```python
None
```

### Scan

```python
An operator that take a list of values together with an initial state
an emits a sequence of resulting states.
Similar to 'reduce', but also emits all previous states if required.

This implies "scan[f][state_ini] | last = reduce[f][state_ini]".

Equivalent to Python's builtin 'accumulate', but named differently
to be consistent with ReactiveX and the nomenclature in the
live data streaming community.

This is also called 'scan' in reactiveX and Scala, 'scanl' in
Haskell and accumulate in python itertools. Similar to reduce,
but returns a sequence with each intermediate result. Essentially
this is the operator equivalent to event sourcing or the state model
in React/Redux and Elm.

Note: On the very first call s='a' and el='b' are used

---- Examples ----
>>> ['a', 'b', 'c', 'd', 'e'] | scan[lambda s, el: s+el]
>>> # => [    'a', 'ab', 'abc', 'abcd', 'abcde']

---- Signature ----
(List[T1], ((T2, T1)->T2), T2)  ->  List[T2]
```

### GroupBy

```python
categories is optional and specifies additional keys/categories
to create, even if there are no occurrences. Passed as a list
[True, False]

---- Tags ----
- used for: control flow
- operates on: List
```

### Transpose

```python
This operator is essentially the operation of transposition on a matrix
that is infinite along one direction (vertical (m) for the
input matrix in normal A_(m,n) nomenclature).
It is different from "interleave" in that it produces a List of Lists,
whereas "interleave" flattens it out into one List.

Note that transposing is its own inverse: transposing twice leads to the
original List, if the operation succeeds.

---- Examples ----
>>> [ [2,3,4], [5,6,7] ]                    # => [ [2, 5], [3,6], [4,7] ]
>>>
>>> # terminates upon the shortest one:
>>> [ range(2, infinity), [5,6], [15,16,17] ]    # => [[2, 5, 15], [3, 6, 16]]

---- Tags ----
- used for: list manipulation
- used for: linear algebra
- same naming as: C++ Ranges V3
```

### Frequencies

```python
None
```

### Iterate

```python
for a homomorphism f and initial val x: [x, f(x), f(f(x)), ...].
Inspired by the excellent talk by Joel Grus on functional Python.

---- Examples ----
>>> 42 | iterate[lambda x: x+1]                                         # => [42, 43, 44, ...]
>>>
>>> # find all of Joe's friends on a graph up to third degree
>>> ([z_joe, ]
>>>   | iterate[lambda z: z >> L[RT.FriendOf] | concat | distinct]      # flatten out and remove duplicates
>>>   | take[3]
>>> )


---- Signature ----
(T, (T->T)) -> List[T]
```

### Identity

```python
None
```

### Length

```python
None
```

### Take

```python
positive n: take n first items. Operates lazily and supports infinite iterators.
negative n: take n last items. Must evaluate entire iterable, does not terminate
for infinite iterables.


---- Signature ----
(List[T], Int) -> List[T]
```

### TakeWhile

```python
None
```

### TakeWhilePair

```python
use when termination of sequence depends on two successive elements.
Generates items until the predicate function returns false for the first time.
Emits both elements given to the predicate function upon the last call.

---- Examples ----
>>> (2
>>>   | ops.iterate[lambda n: n+1 if n < 10 else 10]
>>>   | take_while_pair[lambda m,n: m!=n]
>>>   ) # =>   [2, 3, 4, 5, 6, 7, 8, 9, 10]

---- Signature ----
(List[T], ((T*T)->Bool)) -> List[T]
```

### TakeUntil

```python
Similar to take_while, but with negated predicate and
it includes the bounding element. Useful in some cases,
but take_while is more common.

---- Examples ----
>>> range(10) | take_until[lambda x: x>4] | collect       # => [0, 1, 2, 3, 4, 5]

---- Signature ----
(List[T], (T->Bool)) -> List[T]
```

### SkipWhile

```python
None
```

### Drop

```python
Drop the first n elements of the sequence
```

### Skip

```python
Skip the first n elements of the sequence.
This can be done lazily.

For negative n the counting is done from the back.
This cannot be done lazily: one needs to know when the
list / iterator / stream ends before emitting the
first element.

---- Examples ----
>>> range(10) | skip[3]                         # => [3,4,5,6,7,8,9]
>>> ['a', 'b', 'c', 'd'] | skip[-2]             # => ['a', 'b']

---- Signature ----
(List[T], Int) -> List[T]
```

### Nth

```python
Returns the nth element of an iterable or a stream.
Using negative 'n' takes from the back with 'nth[-1]' being the last element.
An Error value is returned if the index is out of bounds.
Note: this uses a zero-indexed convention.

---- Examples ----
>>>['a', 'b', 'c', 'd'] | nth[1]       # => 'b'
>>>['a', 'b', 'c', 'd'] | nth[-2]      # => 'c'
>>>['a', 'b', 'c', 'd'] | nth[10]      # => Error['nth: index out of range using']

---- Arguments ----
iterable: a List[T] / LazyValue[List[T]] / Awaitable[List[T]]
n (Int): a non-negative integer specifying the index of the element to return.

----- Signature ----
(List[T], Int) -> Union[T, Error]
(LazyValue[List[T]], Int) -> LazyValue[Union[T, Error]]
(Awaitable[List[T]], Int) -> Awaitable[Union[T, Error]]
```

### Filter

```python
Filters an iterable or stream lazily.

---- Examples ----
>>> [1,2,3,4,5] | filter[lambda x: x%2 == 0]       # => [2, 4]
>>> [1,2,3,4,5] | filter[greater_than[2]]          # => [3, 4, 5]

---- Arguments ----
itr: a List[T] / LazyValue[List[T]] / Awaitable[List[T]]
pred (Func[(T,), Bool]): a predicate function

----- Signature ----
(List[T], (T->Bool)) -> List[T]

---- Tags ----
- used for: control flow
- operates on: List
```

### SelectKeys

```python
Given a dictionary, return a new dictionary containing
the same key value pairs, but for a specified subset of
keys only.

Based on Clojure's select-keys
https://clojuredocs.org/clojure.core/select-keys

---- Examples ----
>>> {'a': 3, 'b': 2, 'c': 1} | select_keys['a']['f']      # => {'a': 3}

----- Signature ----
(Dict[T1, T2], T1, ...) -> Dict[T1, T2]

---- Tags ----
- operates on: Dict
- related zefop: filter
- related zefop: get
- related zefop: get_in
- related zefop: merge
```

### Modulo

```python
The modulo function.

---- Examples ----
>>> 12 | mod[10]       # => 2

----- Signature ----
(Int, Int) -> Int

---- Tags ----
- operates on: Int
- topic: Maths
```

### SelectByField

```python
An optimized equivalent of calling:
zrs | filter[Z >> O[rt] | value_or[None] | equals[val]]
although the case of val=None is not permitted.

This is implemented in C++. In the future when the native version is as
fast, this will deprecated.

----- Signature ----
(List[ZefRef], RelationType, Any) -> List[ZefRef]

---- Tags ----
- operates on: Graph
- related zefop: filter
```

### Without

```python
Returns the piped iterable without any items that are contained in the
argument. As a special case, dictionaries are returned without any keys
contained in the argument.

Note the syntax of `| without[1]` is not supported. The argument must be an
iterable.

Note that the type of the output is determined by the following operators,
e.g. `{1,2,3} | without[x] | collect` will return a list, even though the
input is a set.

---- Examples ----
>>> [1,2,3] | without[[2]]            # => [1,3]
>>> {'a', 5, 10} | without['abc']     # => [10, 5]
>>> {'a': 1, 'b': 2} | without[['a']] # => {'b': 2}

---- Signature ----
(Iterable, Iterable) => List
(Dict, Iterable) => Dict
```

### First

```python
Return the first element of a list.

---- Examples ----
>>> [1,2,3] | first          # => 1
>>> [] | first               # => Error

---- Signature ----
List[T] -> Union[T, Error]
```

### Second

```python
Return the second element of a list.

---- Examples ----
>>> [1,2,3] | second          # => 2
>>> [1,] | second             # => Error

---- Signature ----
List[T] -> Union[T, Error]
```

### Last

```python
Return the last element of a list.

---- Examples ----
>>> [1,2,3] | first          # => 3
>>> [] | first               # => Error

---- Signature ----
List[T] -> Union[T, Error]
```

### Single

```python
Return the element from a list containing a single element only.

---- Examples ----
>>> [42,] | single          # => 42
>>> [42, 43] | single       # => Error

---- Signature ----
List[T] -> Union[T, Error]
```

### SingleOr

```python
Given an iterable which should contain either 0 or 1 elements and a default, return the element if it exists, otherwise return the default. Lists that are 2 or more elements long cause an Error

---- Examples ----
>>> [42] | single_or[None]          # => 42
>>> [] | single_or[None]            # => None
>>> [42, 43] | single_or[None]      # => Error

---- Signature ----
List[T],T2 -> Union[T, T2, Error]
```

### Zip

```python
can be used with allputs piped in via one tuple,
or other Lists to zip withbeing curried in.

---- Examples ----
>>> (('a', 'b', 'c', 'd'), range(10)) | zip                  # => [('a', 0), ('b', 1), ('c', 2), ('d', 3)]
>>> range(10) | zip['a', 'b', 'c', 'd']                      # => [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]
>>> range(10) | zip['a', 'b', 'c', 'd'][True,False,True]     # => [(0, 'a', True), (1, 'b', False), (2, 'c', True)]
>>> (('a', 'b', 'c', 'd'), range(10)) | zip | zip            # => [('a', 'b', 'c', 'd'), (0, 1, 2, 3)]
```

### Concat

```python
Concatenate a list of lists (or streams).
Can also be used to specify other lists to be concatenated as
additional args curried in.

---- Examples ----
>>> # A) all passed in via a List of Lists (no args curried into concat op)
>>> [
>>>     [1,2,3],
>>>     ['a', 'b', 'c', 'd'],
>>> ] | concat                                      # =>  [1, 2, 3, 'a', 'b', 'c', 'd']
>>>
>>> # B) One list piped in, other lists to concatenated curried into op
>>> [1,2,3] | concat[ (42,43) ][('a','b','c')]      # =>  [1, 2, 3, 42, 43, 'a', 'b', 'c']

---- Signature ----
(List[T1], List[T2], ...)        -> List[T1 | T2 | ...]
(Stream[T1], Stream[T2], ...)    -> Stream[T1 | T2 | ...]
(String, String, ...)            -> String

---- Tags ----
- operates on: List
- operates on: Stream
- operates on: String
- related zefop: interleave
- related zefop: interleave_longest
- related zefop: merge
- related zefop: append
- related zefop: prepend
- used for: list manipulation
- used for: stream manipulation
- used for: string manipulation
```

### Prepend

```python
Prepend an element to a list / observable.
Special overload for strings as well.

---- Examples ----
>>> ['b', 'c'] | prepend['a']           # => ['a', 'b', 'c']
>>> 'morning' | prepend['good ']        # => 'good morning'

---- Signature ----
(List[T1], T2)    -> List[T1 | T2]
(Stream[T1], T2)  -> Stream[T1 | T2]
(String, String)  -> String

---- Tags ----
- operates on: List
- operates on: Stream
- operates on: String
- related zefop: append
- related zefop: insert_at
- used for: list manipulation
- used for: string manipulation
```

### Append

```python
Append an element to a list / observable.
Special overload for strings as well.

---- Examples ----
>>> ['b', 'c'] | append['d']           # => ['b', 'c', 'd']
>>> 'good' | append[' evening']        # => 'good evening'

---- Signature ----
(List[T1], T2)    -> List[T1 | T2]
(Stream[T1], T2)  -> Stream[T1 | T2]
(String, String)  -> String

---- Tags ----
- operates on: List
- operates on: Stream
- operates on: String
- related zefop: prepend
- related zefop: insert_at
- used for: list manipulation
- used for: string manipulation
```

### Interleave

```python
Interleaves elements of an arbitrary number M of lists.
Length of output is determined by the length of the
shortest input list N_shortest: M*N_shortest

---- Examples ----
>>> # Either called with a list of of lists (or equivalent for streams)
>>> [
>>>     [1,2,3],
>>>     ['a', 'b', 'c', 'd']
>>> ] | interleave          # =>  [1, 'a', 2, 'b', 3, 'c']
>>>
>>> # or with other lists to interleave with being curried in
>>> [1,2,3] | interleave[42 | repeat]       # => [1, 42, 2, 42, 3, 42]
>>> [1,2,3] | interleave[42 | repeat][('a','b')]      # => [1, 42, 'a', 2, 42, 'b']

---- Signature ----
List[List[T]] -> List[T]

---- Tags ----
- related zefop: interleave_longest
- related zefop: concat
- related zefop: merge
- operates on: List
- same naming as: C++ Ranges V3
```

### InterleaveLongest

```python
Interleaves elements of an arbitrary number M of lists.
Length of output is determined by the length of the
longest input list

---- Examples ----
>>> # Either called with a list of of lists (or equivalent for streams)
>>> [
>>>     [1,2,3],
>>>     ['a', 'b', 'c', 'd']
>>> ] | interleave_longest          # =>  [1, 'a', 2, 'b', 3, 'c', 'd']
>>>
>>> # or with other lists to interleave with being curried in
>>> [1,2,3] | interleave_longest[[42]*5]        # => [1, 42, 2, 42, 3, 42, 42, 42]
>>> [1,2,3] | interleave_longest[[42]*5][('a','b')]      # => [1, 42, 'a', 2, 42, 'b', 3, 42, 42, 42]

---- Signature ----
List[List[T]] -> List[T]

---- Tags ----
- related zefop: interleave_longest
- related zefop: concat
- related zefop: merge
- operates on: List
```

### Sort

```python
An optional key function for sorting may be provided, e.g.
list_of_strs | sort[len]

---- Signature ----
List[T] -> List[T]
(List[T], (T->T2)) -> List[T]       # T2 orderable
```

### Now

```python
Caution: impure!

The 'now' operator provides the link between the physical
time at which the computation is executed and the "time"
that is part of the inherent data that is operated on and
that is also often saved as data on graphs.

It can be used in a variety of contexts:
a)  As a nullary function (i.e. calling it without arguments)
    returns the current physical time.
b)  As a transformational operator that changes the reference
    frame to the currently executing process, i.e. the thread
    performing the computation at the very time this operation
    is called.

It is impure, since calling it at different physical times will
give different outputs.
Impurity is transitive: any function calling it is also impure.

---- Examples ----
now()                                   # returns current time (of type Time)
g | now                                 # latest graph slice
gs | now                                # latest graph slice
z_zr_my_entity | now                    # ZefRef -> ZefRef:     fast forward to very latest reference frame at time of execution
z_ezr_my_entity | now                   # EZefRef -> ZefRef:    fast forward to very latest reference frame at time of execution
z_ezr_my_entity[allow_tombstone] | now  # EZefRef -> ZefRef:    flag allows representing RAEs that were terminated.

---- Signature ----
() -> Time
Graph -> GraphSlice
GraphSlice -> GraphSlice
ZefRef -> ZefRef
EZefRef -> ZefRef
(ZefRef, ZefOp) -> ZefRef
(EZefRef, ZefOp) -> ZefRef
```

### Events

```python
Given a TX as a (E)ZefRef, return all events that occurred in that TX.
Given a ZefRef to a RAE, return all the events that happend on the RAE.

- filter_on allows for filtering on the type of the events; by default it is none which
returns all events.

---- Examples ----
>>> z_tx  | events                          => [instantiated[z1], terminated[z3], value_assigned[z8][41][42] ]
>>> z_rae | events                          => [instantiated[z1], value_assigned[z8][41][42], terminated[z3]]
>>> z_rae | events[Instantiated]            => [instantiated[z1]]
>>> z_rae | events[Instantiated | Assigned] => [instantiated[z1], value_assigned[z8][41][42]]

---- Signature ----
Union[ZefRef[TX], EZefRef[TX]]  ->  List[ZefOp[Union[Instantiated[ZefRef], Terminated[ZefRef], ValueAssigned[ZefRef, T]]]]
```

### ToDelegate

```python
None
```

### DelegateOf

```python
None
```

### In

```python
Traverse along a unique Incoming relation to the
thing attached to the source of that relation.
If there is no or multiple incoming relations,
it will return an Error.

For a ZefRef, it will always stay in the same time
slice of the given graph.

When Used on an EZefRef, the eternal graph is traversed.

---- Examples ----
>>> z1s_friend = z1 | In[RT.FriendOf]

---- Signature ----
ZefRef -> ZefRef | Error
EZefRef -> EZefRef | Error
```

### Ins

```python
Traverse along all incoming relation of the specified
type to the thing attached to the source of each relation.

For a ZefRef, it will always stay in the same time
slice of the given graph.

When Used on an EZefRef, the eternal graph is traversed.

---- Examples ----
>>> z1s_friend = z1 | Ins[RT.FriendOf]

---- Signature ----
ZefRef -> ZefRefs
EZefRef -> EZefRefs
```

### Out

```python
Traverse along a unique outgoing relation to the
thing attached to the target of that relation.
If there is no or multiple outgoing relations,
it will return an Error.
This function can also be used by specifying logical
subtypes. The edge type `rt` to traverse on can
be seen as the type to filter the instances of
outgoing edges on, i.e. as special case of pattern
matching.

The default value for `rt` is VT.Any, i.e. no filtering
on the relation type is performed and it is assumed
that a single outgoing relation of any type exists.

For a ZefRef, it will always stay in the same time
slice of the given graph.

When Used on an EZefRef, the eternal graph is traversed.

---- Examples ----
>>> z1s_friend = z1 | Out[RT.FriendOf]
>>> z1s_friend = z1 | Out

---- Signature ----
ZefRef -> ZefRef | Error
EZefRef -> EZefRef | Error
```

### Outs

```python
Traverse along all outgoing relation of the specified
type to the thing attached to the target of each relation.

For a ZefRef, it will always stay in the same time
slice of the given graph.

When Used on an EZefRef, the eternal graph is traversed.

---- Examples ----
>>> z1s_friend = z1 | Outs[RT.FriendOf]

---- Signature ----
ZefRef -> ZefRefs
EZefRef -> EZefRefs
```

### InRel

```python
Traverse onto a unique incoming relation of the specified
type and return the relation (it does NOT proceed to the source).
In case of no or multiple incoming relations of
the specified type, it will return an Error.

For a ZefRef, it will always stay in the same time
slice of the given graph.

When Used on an EZefRef, the eternal graph is traversed.

---- Examples ----
>>> z1s_friend = z1 | in_rel[RT.FriendOf]

---- Signature ----
ZefRef -> ZefRef | Error
EZefRef -> EZefRef | Error
```

### InRels

```python
Traverse onto all incoming relations of the specified
type and return the relations (it does NOT proceed
to the sources).

For a ZefRef, it will always stay in the same time
slice of the given graph.

When Used on an EZefRef, the eternal graph is traversed.

---- Examples ----
>>> z1s_friends = z1 | in_rels[RT.FriendOf]

---- Signature ----
ZefRef -> ZefRefs
EZefRef -> EZefRefs
```

### OutRel

```python
Traverse onto a unique outgoing relation of the specified
type and return the relation (*NOT* the target).
In case of no or multiple outgoing relations of
the specified type, it will return an Error.

For a ZefRef, it will always stay in the same time
slice of the given graph.

When Used on an EZefRef, the eternal graph is traversed.

---- Examples ----
>>> z1s_friend = z1 | out_rel[RT.FriendOf]

---- Signature ----
ZefRef -> ZefRef | Error
EZefRef -> EZefRef | Error
```

### OutRels

```python
Traverse onto all outgoing relations of the specified
type and return the relations (it does NOT proceed
to the targets).

For a ZefRef, it will always stay in the same time
slice of the given graph.

When Used on an EZefRef, the eternal graph is traversed.

---- Examples ----
>>> z1s_friends = z1 | out_rels[RT.FriendOf]

---- Signature ----
ZefRef -> ZefRefs
EZefRef -> EZefRefs
```

### InOld

```python
partial(func, *args, **keywords) - new function with partial application
of the given arguments and keywords.
```

### InInOld

```python
partial(func, *args, **keywords) - new function with partial application
of the given arguments and keywords.
```

### OutOld

```python
partial(func, *args, **keywords) - new function with partial application
of the given arguments and keywords.
```

### OutOutOld

```python
partial(func, *args, **keywords) - new function with partial application
of the given arguments and keywords.
```

### InsOld

```python
None
```

### OutsOld

```python
None
```

### InsAndOutsOld

```python
None
```

### Source

```python
None
```

### Target

```python
None
```

### Value

```python
None
```

### Time

```python
Return the time of the object.

---- Signature ----
ZefRef[TX]  -> Time
EZefRef[TX] -> Time
GraphSlice  -> Time
```

### TimeSlice

```python
Returns the time slice as an Int for GraphSlice.

Note: we may introduce z_tx | time_slice if we can find a convincing use case.
We're leaving it out for now, since this builds on the prior confusion
of identifying transactions themselves with time slice.
The new mental image is that reference frames are somewhat distinct from
TXs and a time slice applies to a reference frame, not a TX directly.

---- Examples ----
>>> my_graph_slice | time_slice

---- Signature ----
GraphSlice -> Int
```

### Tx

```python
let zr: ZefRef  ezr: EZefRef
zr | tx[instantiated]       # keeps ref. frame of zr, returns a ZefRef:
zr | tx[terminated]
```

### NextTX

```python
Given a ZefRef/EZefRef to a tx, move to the next tx.
For a ZefRef with a reference frame, one cannot look
into the future, i.e. get to a TX that was not known
in that reference frame. Nil is returned in that case.

For Both ZeFfRef/EZefRef, Nil is returned when called
on the very lastest TX.

---- Examples ----
z2_tx = z_tx | next_tx | collect

---- Signature ----
ZefRef -> Union[ZefRef, Nil]
EZefRef -> Union[EZefRef, Nil]
```

### PreviousTX

```python
Given a ZefRef/EZefRef to a tx, move to the previous tx.
If one tries to go back from the very first tx, nil is
returned.

---- Signature ----
ZefRef -> Union[ZefRef, Nil]
EZefRef -> Union[EZefRef, Nil]

z2_tx = z_tx | previous_tx | collect
```

### InstantiationTx

```python
None
```

### TerminationTx

```python
None
```

### Instances

```python
None
```

### Uid

```python
None
```

### Frame

```python
Extract the reference frame (subject) of a ZefRef.
Return as a GraphSlice.

---- Examples ----
>>> z_tx_zr | frame        # returns the subject (not object pointed to!) / reference frame as a GraphSlice
>>> z_et | frame           # returns the reference frame (GraphSlice)
>>> z_aet | frame          # returns the reference frame (GraphSlice)
>>> z_rt | frame           # returns the reference frame (GraphSlice)

---- Signature ----
ZefRef -> GraphSlice
```

### DiscardFrame

```python
Given any kind of reference referring to a RAE,
it returns the frame-independent representation.

---- Signature ----
ZefRef[ET[T1]] -> Entity[T1]
ZefRef[AET[T1]] -> AtomicEntity[T1]
ZefRef[RT[T1]] -> Relation[T1]
ZefRef[BT.TX] -> TX           # TODO
ZefRef[BT.Root] -> Graph      # TODO

EZefRef[ET[T1]] -> Entity[T1]
EZefRef[AET[T1]] -> AtomicEntity[T1]
EZefRef[RT[T1]] -> Relation[T1]
EZefRef[BT.TX] -> TX          # TODO
EZefRef[BT.Root] -> Graph     # TODO

Entity[T1] -> Entity[T1]
AtomicEntity[T1] -> AtomicEntity[T1]
Relation[T1] -> Relation[T1]

---- Tags ----
```

### BaseUid

```python
None
```

### OriginUid

```python
used in constructing GraphDelta, could be useful elsewhere
```

### OriginRAE

```python
For RAEs, return an abstract entity, relation or atomic entity. For delegates, acts as the identity.
```

### ExistsAt

```python
None
```

### IsZefRefPromotable

```python
None
```

### InFrame

```python
Represent a RAE in a specified reference frame.
No changes are made to the graph and an error is returned if the operation is not possible,

 - optional arguments: in_frame[allow_tombstone]

---- Examples ----
>>> z | in_frame[my_graph_slice]                    # z: ZefRef changes the reference frame, also if z itself points to a tx
>>> z | in_frame[allow_tombstone][my_graph_slice]   # allow can opt in to represent RAEs that were terminated in a future state

---- Signature ----
(ZefRef, GraphSlice)        -> Union[ZefRef, Error]
(EZefRef[TRAE], GraphSlice) -> Union[ZefRef, Error]
```

### ToGraphSlice

```python
Return the object (tx pointed to by a ZefRef[TX]) as a GraphSlice.
Works for ZefRef[TX] and EZefRef[TX] as well as (Graph, Time) pairs in both orders.
z_tx_zr | to_graph_slice           # ZefRef  -> GraphSlice,     discards reference frame, returns a GraphSlice
z_tx_ezr | to_graph_slice          # EZefRef -> GraphSlice      returns a GraphSlice

---- Examples ----
>>> t1: Time = now()
>>> g | to_graph_slice[t1]
>>> t1 | to_graph_slice[g]
```

### ToTx

```python
Given a GraphSlice (reference frame), return a ZefRef[TX] to the
transaction that led to this state.
The ZefRef has the same transaction as object and subject (ref frame).

---- Examples ----
>>> my_graph_slice | to_tx     # => ZefRef[TX]

---- Signature ----
GraphSlice    -> ZefRef[TX]
(Graph, Time) -> ZefRef[TX]
```

### TimeTravel

```python
Move the reference frame in time only.
The temporal movement can absolute: p is a Time
or relative: p is a Int (move this number of graph slices) or a duration
i.e. the eternal graph of the reference frame
remains contant.

---- Examples ----
>>> #       ---- relative time travel ----
>>> zr | time_travel[-3]                    # how many time slices to move
>>> zr | time_travel[-3.5*units.seconds]
>>> my_graph_slice | time_travel[-3]
>>>
>>> #       ---- absolute time travel ----
>>> t1 = Time('October 20 2020 14:00 (+0100)')
>>> g | time_travel[t1]
>>> gs | time_travel[t1]
>>> ezr | time_travel[t1]
>>> zr | time_travel[t1]
>>>
>>> ezr | time_travel[allow_tombstone][t1]
>>> zr | time_travel[allow_tombstone][-3]
>>> zr | time_travel[allow_tombstone][-3.5*units.seconds]
>>> zr | time_travel[allow_tombstone][t1]

---- Signature ----
(ZefRef, Int)                           -> Union[ZefRef, Nil]           # nil or error? What is the process / criterion?
(ZefRef, Duration)                      -> Union[ZefRef, Nil]
(GraphSlice, Int)                       -> Union[GraphSlice, Nil]
(GraphSlice, Duration)                  -> Union[GraphSlice, Nil]

(ZefRef, Time)                          -> Union[ZefRef, Nil]
(EZefRef, Time)                         -> Union[ZefRef, Nil]
(Graph, Time)                           -> Union[GraphSlice, Nil]
(GraphSlice, Time)                      -> Union[GraphSlice, Nil]

---- Tags ----
- used for: time traversal
- related zefop: time_slice
```

### ToEZefRef

```python
None
```

### O

```python
O[...]  is "optional", meaning it will return either 0,1 results.
If the RT.Edge  exists it'll traverse that and return a ZefRef
If the RT.Edge  doesn't exist, it'll return None or nothing .
If there are multiple RT.Edge  it'll throw an error

---- Examples ----
>>> z1 >> O[RT.Foo]        # of type {ZefRef, None, Error}
```

### L

```python
None
```

### Terminate

```python
None
```

### AssignValue

```python
None
```

### ET

```python
None
```

### RT

```python
None
```

### AET

```python
None
```

### BT

```python
None
```

### FillOrAttach

```python
None
```

### Assert

```python
None
```

### HasOut

```python
None
```

### HasIn

```python
None
```

### Run

```python
None
```

### Tap

```python
None
```

### Push

```python
A pure operator that constructs an effect (a value)
to push an element into a pushable stream.

---- Examples ----
>>> {'msg': 'hello'} | push[my_pushable_stream]                     # returns an effect
>>> my_msg_stream | subscribe[push[my_pushable_stream]]             # messages are transformed into Effects and executed upon arrival
>>>
>>> # upcoming functionality
>>> my_effect | push[z_process]         # wraps an effect as a task effect that will be routed and potentially executed on the specified process
>>> my_effect | push[zefhub]

---- Signature ----
(T, Stream) -> Effect
```

### IsA

```python

```

### IsRepresentedAs

```python
None
```

### RepresentationType

```python
Warning: this function is not complete and its behavior may change!!!!!!!!!!!

Returns a Zef ValueType_ (a value itself),
also when used with the python builtin supported
types, as well as with instances of Zef Values.

TODO:
my_ent | representation_type   # Entity[ET.Foo]
z | representation_type        # ZefRef[ET.Foo]
ez| representation_type        # EZefRef[ET.Foo]

ET.Foo | representation_type    # ET
ET     | representation_type    # ValueType
```

### HasRelation

```python
None
```

### Relation

```python
None
```

### Relations

```python
None
```

### Chunk

```python
This one is tricky. We'll be opinionated and eagerly evaluate the
elements in each chunk, as the chunks are being asked for. The
chunks are returned as a generator.

If the input is an iterable (could be infinite generator or not),
this returns a generator of generators. An operator downstream could
choose to evaluate the terms of a later iterator before those of an
earlier one emitted here. If we can't access via ...[], we have to
iteratively step through.

Be opinionated here: instead of going full in with checking whether
the iterable has random access ...[n] semantics (C++ has the more
detailed model built in for this), we'll perform caching.

Perform caching and store the evaluated values in case these are
to be accessed by the earlier iterable. Keep them up to the point
until the earlier iterable has consumed them, then discard them.

---- Examples ----
>>> range(8) | chunk[3]          # => [[0, 1, 2], [3, 4, 5], [6, 7]]
>>> 'abcdefgh' | chunk_imp[3]    # => ['abc', 'def', 'gh']

---- Signature ----
(List[T], Int)   -> List[List[T]]
(Stream[T], Int) -> Stream[Stream[T]]
(String, Int)   -> List[String]

---- Tags ----
operates on: List
operates on: String
operates on: Stream
used for: list manipulation
used for: string manipulation
used for: stream manipulation
related zefop: stride
related zefop: sliding
related zefop: slice
```

### Sliding

```python
Given a list, return a list of internal lists of length "window_size".
"stride_step" may be specified (optional) and determines how
many elements are taken forward in each step.
Default stride_step if not specified otherwise: 1.

---- Examples ----
>>> range(5) | sliding[3]       # [(0, 1, 2), (1, 2, 3), (2, 3, 4)]
>>> range(5) | sliding[3][2]    # [(0, 1, 2), (2, 3, 4)]

---- Signature ----
(List[T], Int, Int) -> List[List[T]]

---- Tags ----
- related zefop: stride
- related zefop: chunk
- related zefop: slice
- operates on: List

implementation follows Scala's, see https://stackoverflow.com/questions/32874419/scala-slidingn-n-vs-groupedn
```

### Stride

```python
Return a new list where only every nth
(specified by the stride step) is sampled.

---- Examples ----
>>> Range(8) | stride[3]     #  [0, 3, 6]

---- Signature ----
(List[T], Int) -> List[T]

---- Tags ----
operates on: List
operates on: String
operates on: Stream
used for: list manipulation
used for: string manipulation
used for: stream manipulation
related zefop: chunk
related zefop: sliding
related zefop: slice
```

### Insert

```python
Takes a dictionary / flatgraph together with something to insert
and returns a new dictionary / flatgraph with that inserted.
The input values are not mutated or harmed during this operation.


---- Examples ----
>>> {'a': 1} | insert['b'][2]   ->  {'a': 1, 'b': 2}
>>> FlatGraph() | insert[ET.God, RT.Favorite, Val(1/137)] | insert[ET.BigBang]

---- Signature ----
(Dict[T1][T2], T1, T2) -> Dict[T1][T2]

---- Tags ----
- level: easy
- used for: control flow
- operates on: Dict
- operates on: FlatGraph
- related zefop: insert_in
- related zefop: remove
- related zefop: update
```

### InsertInto

```python
Unclear whether we need this. To insert a key value
pair into a dictionary, one could cast to a dict and use merge.
But this may be shorter.

This function could also be used on Lists.

---- Examples ----
>>> (2, 'a') | insert_into[ range(4) ]    # [0,1,'a',2,3]

---- Signature ----
((T1, T2), Dict[T3][T4]) -> Dict[T1|T3][T2|T4]

# TODO: make this work: (10, 'a') | insert_into[range(10) | map[add[100]]] | take[5] | c
```

### ReverseArgs

```python
Useful to transform one zefop into a new operator where
the only difference is that the arguments are reversed.
This applies when we want an operator where the dataflow
is determined by a different argument than the usual one.

Suppose we want to have the op 'insert_into', which is a
slight variation of "insert":
('my_key': 42) | insert_into[{'a':1}]

With this operator, we can construct "insert_into" on the fly:
>>> insert_into = reverse_args[insert]

---- Examples ----
>>> ('my_key': 42) | reverse_args[insert][{'a':1}]      # {'my_key': 42, 'a': 1}
>>> 'x' |  reverse_args[get][{'a':1, 'x': 42}]          # 42

---- Signature ----
(T1, ZefOp[T..., T1][T2], T...) -> T2

---- Tags ----
- level: advanced
- used for: control flow
- operates on: ZefOps
- operates on: Functions
- related zefop: func
- related zefop: apply_functions
```

### Remove

```python
Given a key and a dictionary, returns a new dictionary
with the key value pair removed.

This operator is NOT overloaded for Lists, since this
could be confused with the mutating Python method on
lists: my_list.remove(2) removes the first occurrence
of the VALUE "2" and not at the location.
Use "remove_at" for lists.

---- Examples ----
>>> {'a': 1, 'b', 2} | remove['a']   ->  {'b': 2}

---- Tags ----
- operates on: Dict
- related zefop: remote_at
- related zefop: remote_in
- related zefop: insert
- related zefop: get
```

### Get

```python
Typically used for key lookups, equivalent to '[]' operator.
External function equivalent to Python's '__get__' method.
Default values can be provided

---- Examples ----
>>> {'a': 42, 'b': 'hello'} | get['a']                    # => 42
>>> {'a': 42, 'b': 'hello'} | get['a']                    # => 42

----- Signature ----
(Dict[T1, T2], T1) -> T2
(Graph, T1) -> Any
(FlatGraph, T1) -> Any

---- Tags ----
- operates on: Dict
- operates on: Graph
- operates on: FlatGraph
- related zefop: get_in
- related zefop: get_field
- related zefop: insert
- related zefop: remove
- related zefop: select_in
```

### GetField

```python
Specific to python. Get the attribute of an object, equivalent to
getattr(obj, field).

---- Examples ----
# Note: the following example is much better expressed as ET("Machine")
>>> ET | get_field["Machine"]                # => ET.Machine

# Note: the nodes of a NetworkX graph can be accessed via, e.g. list(nxg.nodes)
>>> nxg | get_field["nodes"] | filter[...]

----- Signature ----
(T, String) -> T2

---- Tags ----
- related zefop: get
```

### Enumerate

```python
Given an iterable, returns an iterable of pairs where
the first is an incrementing integer starting at zero.

---- Examples ----
>>> ['a', 'b', 'c'] | enumerate     # [(1, 'a'), (2, 'b'), (3, 'c')]

---- Signature ----
List[T1] -> List[Tuple[Int, T1]]
Stream[T1] -> Stream[Tuple[Int, T1]]
String -> List[Tuple[Int, String]]

---- Tags ----
- used for: list manipulation
- used for: string manipulation
- used for: lazy transformation
```

### Items

```python
Return the key-value pairs of a dictionary as a tuple.

---- Examples ----
>>> {'a': 100, 42: 'die antwoord', 'c': True} | values           # ( ('a', 100), (42, 'die antwoord'), ('c', True) )

---- Signature ----
Dict[T1][T2] -> List[Tuple[T1, T2]]

---- Tags ----
- used for: dict manipulation
- used for: list manipulation
```

### Values

```python
Return the values of a dictionary

---- Examples ----
>>> {'a': 100, 42: 'die antwoord', 'c': True} | values           # (100, 'die antwoord', True)

---- Signature ----
Dict[T1][T2] -> List[T2]

---- Tags ----
- used for: dict manipulation
- used for: list manipulation
```

### Keys

```python
Return the keys of a dictionary

---- Examples ----
>>> {'a': 100, 42: 'die antwoord', 'c': True} | keys           # ('a', 42, 'c')

---- Signature ----
Dict[T1][T2] -> List[T1]

---- Tags ----
- used for: dict manipulation
- used for: list manipulation
```

### Reverse

```python
Reverse a list or equivalent structure.

---- Examples ----
>>> [2,3,4] | reverse           # [4,3,2]
>>> 'straw' | reverse           # 'warts'

---- Signature ----
List[T1] -> List[T1]
Stream[T1] -> Stream[T1]
String -> String

---- Tags ----
- used for: list manipulation
- used for: stream manipulation
```

### RaeType

```python
None
```

### AbstractType

```python
None
```

### Root

```python
Retrieve the root node for a Graph or Graph Slice.

---- Examples ----
>>> g | root
>>> g | now | root

---- Signature ----
Graph -> EZefRef
GraphSlice -> ZefRef

---- Tags ----
- used for: graph traversal
```

### Schema

```python
Returns all schema nodes on the graph or alive in the given GraphSlice.
These are the delegate entities/relations which reference all instances on
the graph.

The optional argument `include_edges` can be set to True to also return the
low-level edges between these nodes, which is useful for plotting with
`graphviz`.

---- Examples ----
>>> g | schema[True] | graphviz          # Shows the schema of graph g.
>>> g | now | schema[True] | graphviz    # Shows the schema of graph g in the current time slice.

# A blank graph already has one TX delegate node.
>>> g = Graph()
>>> g | schema | collect
... [<EZefRef #65 DELEGATE TX at slice=0>]

---- Signature ----
(Graph, Bool) => List[EZefRef]
(GraphSlice, Bool) => List[ZefRef]
```

### Z

```python
None
```

### Docstring

```python
Return the docstring for a given ZefOp or Zef Function.

---- Examples ----
>>> docstring(nth)
```

### SourceCode

```python
Return the function body for a given ZefOp or Zef Function.

---- Examples ----
>>> source_code(insert_at) | to_clipboard | run
```

### GetIn

```python
Enable one-shot access to elements in nested dictionary
by specifying path as a tuple of keys.
Based on Clojure's 'get-in'.

---- Examples ----
>>> {'a': 1, 'b': {'c': 1}} | get_in[('b', 'c')]   # => 1
>>> {'a': 1, 'b': {'c': 1}} | get_in[('b', 'wrong_key')][42]   # => 42
```

### InsertIn

```python
---- Examples ----
>>> {'a': 1, 'b': {'c': 1}} | insert_in[('b', 'd')][42]   # => {'a': 1, 'b': {'c': 1, 'd': 42}}
```

### Update

```python
Change the value for a given key / index by applying a
user provided function to the old value at that location.

Note: the equivalent ZefOp to use on Lists is "update_at"
(to be consistent with "remove_at" for Lists and
disambiguate acting on the value)

{'a': 5, 'b': 6} | update['a'][add[10]]   # => {'a': 15, 'b': 6}

---- Tags ----
- related zefop: update_at
- related zefop: update_in
- related zefop: get
- related zefop: insert
- operates on: Dict
- used for: control flow
- used for: function application
```

### UpdateIn

```python
---- Examples ----
>>> {'a': 1, 'b': {'c': 1}} | update_in[('b', 'c')][add[1]]   # => {'a': 1, 'b': {'c': 2}}

---- Signature ----
(Dict, List, T1->T2) -> Dict

---- Tags ----
- related zefop: update
- related zefop: update_at
- related zefop: insert_in
- related zefop: remove_in
- related zefop: get_in
- operates on: Dict
- used for: control flow
- used for: function application
```

### UpdateAt

```python
Apply a specified function "f" to a specified position of
a list using the existing element "el" as function input.
A new list is returned which differs only in that element
which is replaced with "f(el)".
When called with negative index n, this is interpreted as
reverse indexing with -1 referring to the last element.

---- Examples ----
>>> [5,6,7] | update_at[2][add[10]]   # => [5,6,17]

---- Signature ----
(List[T1], T1->T2) -> List[T1|T2]

---- Tags ----
- related zefop: update
- related zefop: update_in
- related zefop: remove_at
- related zefop: replace_at
- operates on: List
- used for: control flow
- used for: function application
```

### InsertAt

```python
Insert a specified value at a specified position of
a list. A new list is returned, the input list is not mutated.
When called with negative index n, this is interpreted as
reverse indexing with -1 referring to the last element.

---- Examples ----
>>> [0,1,2] | insert_at[1]['hello']   # => [0,'hello',1,2]

---- Signature ----
(List[T1], T1->T2) -> List[T1|T2]
(List[T1], T2) -> List[T1|T2]

---- Tags ----
- related zefop: insert
- related zefop: insert_in
- related zefop: update_at
- related zefop: remove_at
- related zefop: replace_at
- operates on: List
- operates on: Stream
- operates on: String
- used for: list manipulation
- used for: stream manipulation
- used for: string manipulation
```

### RemoveIn

```python
Given a dictionary and a tuple describing a path into the dictionary,
this returns a new dictionary with the pointed to value removed.
The original dictionary is not mutated.

---- Examples ----
>>> {'a': 1, 'b': {'c': 1}} | remove_in[('b', 'c')]   # => {'a': 1, 'b': {}}

---- Signature ----
(Dict[T1][T2], List) -> Dict[T1][T2]

---- Tags ----
- related zefop: remove
- related zefop: remove_in
- related zefop: remove_at
- related zefop: update_in
- related zefop: insert_in
- related zefop: get_in
- operates on: Dict
- used for: control flow
- used for: function application
```

### RemoveAt

```python
Using "remove" based on indexes would be confusing,
as Python's list remove, searches for the first
occurrence of that value and removes it.

['a', 'b', 'c'] | remove_at[1]       # => ['a', 'c']
['a', 'b', 'c'] | remove_at[1][0]    # => ['c']

---- Signature ----
List[T] & Length[Z] -> List[T] & Length[Z-1]

---- Tags ----
- related zefop: interleave_longest
- related zefop: concat
- related zefop: merge
- operates on: List
```

### Merge

```python
Merge a dictionaries: either one list of dicts or
dicts as multiple args.

Clojure has a similar operator:
https://clojuredocs.org/clojure.core/merge

---- Examples -----
[{'a': 1, 'b': 42}, {'a': 2, 'c': 43}] | merge          # => {'a': 2, 'b': 42, 'c': 43}
{'a': 1, 'b': 42} | merge[ {'a': 2, 'c': 43} ]

---- Signature ----
List[Dict]          -> Dict
(Dict, Dict)        -> Dict
(Dict, Dict, Dict)  -> Dict

---- Tags ----
* tool for: dictionaries
* similar: merge_with
...
```

### MergeWith

```python
Merge a list of maps, but give an operation to join the values
for matching keys.
The function provided for the merging must be able to operate on
the value type in the dictionary (it suffices if it works for the
value type of the matching keys only).

Based on the Clojure operator https://clojuredocs.org/clojure.core/merge-with

---- Examples ----
{'a': 1, 'b': 2} | merge_with[add][{'a': 3}]                        # => {'a': 4, 'b': 2}
{'a': 1, 'b': 2} | merge_with[add][{'a': 3}, {'b': 10, 'c': 5}]     # => {'a': 4, 'b': 12, 'c': 5}
[{'a': [1], 'b': [2]}, {'a': [3]}] | merge_with[concat]             # => {'a': [1, 2], 'b': [3]}

---- Signature ----
(Dict[T1, T2], ((T2,T2)->T2), Dict[T1, T2]) -> Dict[T1, T2]
(List[Dict[T1, T2]], ((T2,T2)->T2)) -> Dict[T1, T2]
```

### IntToAlpha

```python
Map an integer n to the nth letter of the alphabet.
Always lower case.

---- Examples ----
>>> 3 | int_to_alpha    # => 'c'

---- Tags ----
- operates on: Int
- used for: string manipulation
```

### PermuteTo

```python
given a input list, as well as a list of indices,
return the list of elements arranged according to the
list of indices.

>>> ['a', 'b', 'c', 'd'] | permute_to[2,0,1]    # => ['c', 'a', 'b']

---- Tags ----
- operates on: List
- used for: list manipulation
```

### Cycle

```python
Given a list, this wll produce another list loft the same structure
that cycles thorugh all elements of the original list n times.

e.g. [2,3] | cycle[3]  -> [2,3,2,3,2,3]
cycle[None]:     means never terminate
```

### Repeat

```python
None
```

### Contains

```python
None
```

### ContainedIn

```python
None
```

### All

```python
The all op has two different behaviours:

A) The first is to "find all of" for a graph-like or graph-slice-like
object. Of a GraphSlice/FlatGraph, this will return a ZefRef list of every RAE, and of a
Graph this will return a EZefRef list of every blob.

An optional argument can be a type that provides a filter on the kind of
items returned. It should always be true that: `g | all[Type]` is equivalent
to `g | all | filter[is_a[Type]]` however providing the Type to `all` can be
much more efficient.

B) The second behaviour is to test the truth of every element in a list. It
is similar to the builtin `all` function of python. If the list is empty,
returns True.

---- Examples ----
>>> g | now | all[ET]       # all entities in the latest timeslice of the graph

>>> g | all[TX]             # all transaction blobs in the graph

>>> [True,True] | all   # => True
>>> [False,True] | all  # => False
>>> [] | all            # => True

Test whether all ZefRefs have an RT.Name relation.
>>> zrs | map[has_out[RT.Name] | all

---- Signature ----
List[T] -> Bool
GraphSliceLike -> List[ZefRef]
GraphLike -> List[EZefRef]
(GraphSliceLike, Type) -> List[ZefRef]
(GraphLike, Type) -> List[EZefRef]

---- Tags ----
- used for: predicates
```

### Any

```python
Given a list of booleans: check whether any of them are true.
Equivalent to the logical 'or' in propositional logic.
Also equivalent to Python's builtin 'any', but pipeable and
applicable to Streams.

An empty list will return False.

---- Examples ----
>>> [False, True, False] | any                 # => True

>>> [False, False, False] | any                # => False

>>> [] | any                                   # => False
```

### Join

```python
join a list of strings with a binding character.
>>> ['foo', 'bar'] | join['-']              # => 'foo-bar'
```

### Trim

```python
None
```

### TrimLeft

```python
None
```

### TrimRight

```python
None
```

### Yo

```python
None
```

### Sign

```python
Utility function that returns the sign of a number (+1/-1).
also: sign(0)=0

---- Signature ----
Union[Int, Float] -> SetOf[-1,0,1] | Error
```

### IfThenElse

```python
Unlike the apply version of this function. If pred evaluates
to true, value1 is returned otherwise value2.

---- Examples ----
>>> 4 | if_then_else[is_even]["even"]["odd"]       # => "even"

---- Signature ----
(Any, (T->Bool), (Any), (Any)) -> Any

---- Tags ----
- used for: control flow
- used for: logic
- related zefop: if_then_else_apply
- related zefop: group_by
- related zefop: match
- related zefop: match_apply
- related zefop: filter
```

### IfThenElseApply

```python
Dispatches to one of two provided functions based on the boolean
result of the predicate function, given the input value.
The input value into the zefop is used by the predicate and
forwarded to the relevant case function.

---- Examples ----
>>> add_one, add_two = add[1], add[2]
>>> 4 | if_then_else[is_even][add_one][add_two]         # => 5

---- Signature ----
((T->Bool), (T->T1), (T->T2)) -> Union[T1, T2]

---- Tags ----
- used for: control flow
- used for: logic
- related zefop: if_then_else
- related zefop: group_by
- related zefop: match
- related zefop: match_apply
- related zefop: filter
```

### Attempt

```python
Wrap an operator to catch errors. If anything goes wrong,
return the user provided alternative value.

---- Examples ----
>>> risky_chain = (
>>>     map[lambda x: 1/x]
>>>   | filter[greater_than[0]]
>>>   | single
>>> )
>>> alternative_val = 42
>>>
>>> [-1,10,-3] | attempt[risky_chain][alternative_val]     # => 0.1
>>> [-1,10,3] | attempt[risky_chain][alternative_val]      # => 42      (single called on list with 2 items)
>>> [-1,0,-3] | attempt[risky_chain][alternative_val]      # => 42      (division by zero)

---- Signature ----
(T, (T-> Union[T1, Error]), T2) -> Union[T1, T2]

---- Tags ----
- used for: control flow
- related zefop: if_then_else
- related zefop: expect
- related zefop: ensure
- related zefop: bypass
```

### Bypass

```python
specify one or a tuple of types that will be bypassed. Otherwise the specified
function will be called and the result returned.

---- Examples ----
>>> my_stream | bypass[Error][my_func]        # any Error will just be forwarded
>>> my_stream | bypass[Error, Int][my_func]
>>> my_stream | bypass[set_of[_1 < 42]][my_func]

---- Signature ----
(List[T, T2], Type(T2), (T -> T3)) -> List[Union[T2, T3]]
```

### Pattern

```python
generates a predicate function given a parameterized pattern for
dicts or list.
It is often used inside the "match" operator.

---- Examples ----
>>> [1,2,3,4,5] | pattern[_any, 2, _any, 4]               # => True
>>> [1,2,3,4,5] | pattern[_any, 2, _any, 5]               # => False
>>>
>>> {'a': 1, 'b': 2} | pattern[{'a': Z}]                  # => True: is there any key a?
>>> {'a': 1, 'b': 2} | pattern[{'a': Z, 'b': 2}]          # => True

---- Signature ----
(List[T], List[Union[T, _Any]]) -> Bool
(Dict[T1, T2], Dict[Union[T1, _Any], Union[T2, _Any]]) -> Bool

---- Tags ----
- operates on: Dict, List
- used for: control flow
- related zefop: match
- related zefop: match_apply
- related zefop: distinct_by
```

### Replace

```python
Replace any specified old value with a new value in a List.

---- Examples ----
>>> ['a', 'b', 'c', 'd'] | replace['b'][42]    # ['a', 42, 'c', 'd']
>>> 'the zen of python' | replace['n']['f']    # 'the zef of pythof'

---- Signature ----
List[T1], T1, T2 -> List[T1 | T2]
Char = String & Length[1]
String, Char, Char -> String

---- Tags ----
- operates on: List, String
- used for: list manipulation
- related zefop: replace_at
- related zefop: insert_in
- related zefop: insert
- related zefop: remove
```

### Distinct

```python
Remove multiple occurrences of the same element (determined
via == comparison evaluating to True). Do this lazily, such
that this can also be applied to lazily.

---- Examples ----
>>> [4,5,4,1,5,4] | distinct        # => [4, 5, 1]

---- Arguments ----
v: an iterable with elements that can be compared

---- Signature ----
List[T] -> List[T]
LazyValue[List[T]] -> LazyValue[List[T]]

---- Tags ----
- operates on: List, Stream
- used for: list manipulation
- related zefop: is_distinct
- related zefop: distinct_by
```

### DistinctBy

```python
Remove multiple occurrences of the same element determining equality
after passing through the function passed in.
Do this lazily, such that this can also be applied to lazily.

---- Examples ----
>>> [-1,2,1,-2] | distinct_by[lambda x: x*x]        # => [-1, 2]

---- Arguments ----
v: an iterable with elements that can be compared
comparison_function: (T, T) -> Bool

---- Signature ----
(List[T], (T->Any)) -> List[T]
LazyValue[(List[T], (T->Any))] -> LazyValue[List[T]]

---- Tags ----
- operates on: List, Stream
- used for: list manipulation
- related zefop: is_distinct_by
- related zefop: distinct
```

### IsDistinct

```python
Used on an iterable / stream of values and
returns a boolean indicating whether all
values are distinct. i.e. as soon as any value
appears more than once, False is returned.

---- Examples ----
>>> [1,2,3] | is_distinct        # => True
>>> [1,2,3,2] | is_distinct      # => False

---- Arguments ----
v: an iterable with elements that can be compared

---- Signature ----
List[T] -> Bool
Stream[T] -> Bool
LazyValue[List[T]] -> Bool

---- Tags ----
- operates on: List, String
- used for: set theory
- related zefop: is_distinct_by
- related zefop: distinct
```

### IsDistinctBy

```python
Very similar to `is_distinct` zefop, but takes a user
provided function `fn` to compare the equality testing with.

---- Examples ----
>>> [1,2] | is_distinct_by[lambda x: x%2]      # => True
>>> [1,2,3] | is_distinct_by[lambda x: x%2]    # => False

---- Arguments ----
v: an iterable with elements that can be compared
fn: the function to be applied elementwise

---- Signature ----
List[T], Callable -> Bool
Stream[T], Callable -> Bool

---- Tags ----
- operates on: List, String
- used for: set theory
- related zefop: distinct_by
- related zefop: is_distinct
```

### Shuffle

```python
Shuffles the elements in a list. If a seed is
provided, this is a pure function.
If no seed is set to None, the system's
RNG is used to draw one. In this case this
operation is impure!


TODO: implement coeffects to get randomness from FX system.

---- Examples ----
>>> ['a', 'b', 'c', 'd'] | shuffle[189237]    # => ['d', 'b', 'a', 'c']

---- Tags ----
- operates on: List
- used for: list manipulation
- used for: randomness
```

### Slice

```python
factor out python-style slicing: ...[5:8].
Negative indexes count from the back.
If three arguments are given from the range, the
last one denotes the step size.

---- Examples ----
>>> ['a', 'b', 'c', 'd'] | slice[1:2]    # => ['b', 'c']
>>> 'abcdefgh' | slice_imp[1,6,2]        # => 'bdf'

---- Tags ----
- operates on: List
- operates on: String
- used for: list manipulation
- used for: string manipulation
- related zefop: take
- related zefop: reverse
- related zefop: first
- related zefop: last
- related zefop: nth
```

### Split

```python
Split a List into a List[List] based on the occurrence of val.
The value that is split on is not contained in any of the output lists.

---- Examples ----
>>> 'abcdeabfb' | split['b']            # => ['a', 'cdea', 'f', '']
>>> [0,1,6,2,3,4,2,] | split[2]         # => [[0, 1, 6], [3, 4], []]

---- Signature ----
(List[T], T) -> List[List[T]]
```

### SplitIf

```python
Similar to split, but the user provides a predicate function
that determines the positions to split on.

The symbols that are split on, are not included in the result.

---- Examples ----
>>> 'good4morning2to6you' | split_if[is_numeric]    # => ['good', 'morning', 'to', 'you']
>>> range(10) | split_if[lambda x: x % 3 == 0 ]     # => [[], [1, 2], [4, 5], [7, 8], []]

---- Signature ----
(List[T], T->Bool) -> List[List[T]]

---- Tags ----
- operates on: List, String
- used for: list manipulation
- used for: string manipulation
- related zefop: split
- related zefop: concat
- related zefop: trim
```

### Graphviz

```python
Returns a GraphViz visualization of the graph passed in.
By default it returns an error if more than 1000 RAEs are to be shown.

Zef graphs are meta-graphs: relations can themselves have outgoing relations
which allows mimicing the behavior of property graphs (with nodes/relations
allowed to contain "objects" / dictionaries).

GraphViz does not allow plotting relations out of relations (please let us
know if we're wrong here and you know a way!). Therefore we need to
map the meta-graph onto a larger true graph (each relation becoming a node)
and subsequently plot this. The downside is the visual clarity:
It may be hard to see which edges/lines are the true edges and which lines
are other incoming/outgoing edges to the actual edge.

As a slight improvement, each relation's color is based on it's type: this
allows identifying the actual relation as the one with and incoming and
outgoing arrow of the same color in case of ambiguity.

---- Examples ----
>>> g | now | all | graph_viz | collect
>>> g | now | all | graph_viz[simplified] | collect     # No extra nodes introduced for relations. Hence: can't show relations out of relations.
>>> g | all | graph_viz | collect                       # show the full eternal graph


---- Signature ----
List[EZefRef] -> Image
List[ZefRef] -> Image
(List[ZefRef], ZefOp) -> Image
```

### Always

```python
Regardless of the input, always return the curried in value.

---- Examples ----
[1,2,3] | map[always[True]]      # => [True, True, True]

match[
    (equals[5], "special case"),
    (always[True], "default")
]

---- Signature ----
(T, T2) -> T2
```

### WithoutAbsorbed

```python
Return the bare Type as if nothing had ever been absorbed.

---- Examples ----
>>> LazyValue(reduce[add[1]][42]) | without_absorbed    # => reduce

---- Tags ----
- used for: control flow
- operates on: ZefOps, Value Types, Entity, Relation, AtomicEntity, ZefRef, EZefRef
- related zefop: absorbed
- related zefop: inject
- related zefop: inject_list
- related zefop: reverse_args
```

### Absorbed

```python
Extract the absorbed values from any absorbing type.

---- Examples ----
>>> reduce[add[1]][42] | absorbed    # => (add[1], 42)

---- Tags ----
- used for: control flow
- operates on: ZefOps, Value Types, Entity, Relation, AtomicEntity, ZefRef, EZefRef
- related zefop: without_absorbed
- related zefop: inject
- related zefop: inject_list
- related zefop: reverse_args
```

### CartesianProduct

```python
Note that Python's itertools calls this "product only", but
but that term is too overloaded, e.g. the 'multiply' operator.

---- Examples ----
>>> [1,2,3] | cartesian_product[('a', 'b')]                   # => [ (1, 'a'), (2, 'a'), (3, 'a'), (1, 'b'), (2, 'b'), (3, 'b') ]
>>> [1,2,3] | cartesian_product[('a', 'b')][(True,False)]     # => [ (1, 'a', True), ...
>>>
>>> or pass in all args:
>>> ([1,2,3], ['a', 'b']) | cartesian_product                 # => [ (1, 'a'), (2, 'a'), (3, 'a'), (1, 'b'), (2, 'b'), (3, 'b') ]

---- Signature ----
List[ List[T1], List[T2] ] -> List[ (T1, T2) ]
(List[T1], List[T2])       -> List[ (T1, T2) ]


---- Tags ----
- operates on: List
- used for: combinatorics
- related zefop: combinations
- related zefop: permutations
```

### Permutations

```python
Given a list of items, return a list of lists with all
permutations lazily. Order within the returned combination
does not play a role.

If given, the second argument is the length of each output.

---- Examples ----
>>> ['a', 'b', 'c'] | permutations
>>> # returns:
>>> # [
>>> #     ['a', 'b', 'c'],
>>> #     ['a', 'c', 'b'],
>>> #     ['b', 'a', 'c'],
>>> #     ['b', 'c', 'a'],
>>> #     ['c', 'a', 'b'],
>>> #     ['c', 'b', 'a']
>>> # ]

>>> [1,2,3] | permutations[2]    # specify the number of elements in each sample
>>> # returns: [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]

---- Signature ----
List[T] -> List[List[T]]
(List[T], Int) -> List[List[T]]

---- Tags ----
- operates on: List
- used for: combinatorics
- related zefop: combinations
- related zefop: cartesian_product
```

### Combinations

```python
Given a list of m elements, return all combinations
of length n. Order within the returned combination
does not play a role.

---- Examples ----
[1,2,3] | combinations[2]      # => [(1, 2), (1, 3), (2, 3)]

---- Signature ----
(List[T], Int) -> List[List[T]]
```

### Add

```python
Adds two elements. Neither is a list.
Don't use this when summing up a list, use `sum`
in that case.

---- Examples ----
40 | add[2]    # => 42

---- Signature ----
(T1, T2) -> T1 | T2

---- Tags ----
used for: maths
related zefop: sum
related zefop: subtract
related zefop: multiply
related zefop: divide
```

### Sum

```python
Sums up all elements in a List.
Similar to the `add` zefop, but to be used in the case of a
single argument being passed as a list.
`add` is used when exactly two elements are passed individually.

---- Signature ----
List[T] -> T

---- Tags ----
used for: maths
operates on: List
related zefop: add
related zefop: product
```

### Product

```python
Multiplies up all elements in a List.
Similar to the `multiply` zefop, but to be used in the case of a
single argument being passed as a list.
`multiply` is used when exactly two elements are passed individually.

---- Signature ----
List[T] -> T

---- Tags ----
used for: maths
operates on: List
related zefop: multiply
related zefop: sum
```

### Subtract

```python
None
```

### Multiply

```python
Multiplies a list of numbers.
We don't use 'product' to name this, as that term is too overloaded.
e.g. in Python itertools this denotes the Cartesian product.
```

### Divide

```python
None
```

### Mean

```python
Calculates the arithmetic mean of a given List / Set of numbers.

---- Signature ----
List[Int] -> Float
Set[Int] -> Float
List[Float] -> Float
Set[Float] -> Float
```

### Variance

```python
Calculates the variance of a given List / Set of numbers.

---- Signature ----
List[Int] -> Float
Set[Int] -> Float
List[Float] -> Float
Set[Float] -> Float
```

### Power

```python
None
```

### Exponential

```python
None
```

### Logarithm

```python
base = None is synonymous with base = 2.718281828459045...
```

### Max

```python
None
```

### Min

```python
None
```

### MaxBy

```python
None
```

### MinBy

```python
None
```

### Equals

```python
None
```

### GreaterThan

```python
None
```

### LessThan

```python
None
```

### GreaterThanOrEqual

```python
None
```

### LessThanOrEqual

```python
None
```

### Not

```python
Takes a single predicate function and returns the negated predicate function.
```

### And

```python
This operator can be used in two ways:

B) Multiary combinator to compose predicate functions.
   Given multiple predicate functions p_1, p_, ...p_m  with
   signature S->Bool, the expression And[]
   a new predicate function of signature S->Bool is returned.
   Short circuiting is accounted for and the functions are
   evaluated in the order they are listed.

A) binary operator on boolean values

---- Examples ----
>>> 10 | And[greater_than[0]][less_than[42]]     # => True
>>> {'x': 42, 'b': 'yo'} | And[contains['x']][ get['b] | length | equals[2] ]

>>> [9,3,1,16] | map[And[greater_than[0]][less_than[5]]]     # => [False, True, True, False]

---- Signature ----
(T, T->Bool, T->Bool, ..., T->Bool ) -> Bool

---- Tags ----
used for: logic
used for: predicated
related zefop: Or
related zefop: Not
related: Intersection
```

### Or

```python
This operator can be used in two ways:

B) Multiary combinator to compose predicate functions.
   Given multiple predicate functions p_1, p_, ...p_m  with
   signature S->Bool, the expression Or[]
   a new predicate function of signature S->Bool is returned.
   Short circuiting is accounted for and the functions are
   evaluated in the order they are listed.

A) binary operator on boolean values

---- Examples ----
>>> 100 | Or[greater_than[0]][less_than[42]]     # => False
>>> [12,7,1] | map[Or[greater_than[10]][less_than[5]]]     # => [True, False, True]

---- Signature ----
(T, T->Bool, T->Bool, ..., T->Bool) -> Bool

---- Tags ----
used for: logic
used for: predicated
related zefop: Or
related zefop: Not
related: Intersection
```

### Xor

```python
None
```

### Peel

```python
None
```

### Match

```python
Given an item and a list of Tuples[predicate, output]. The item is checked
sequentially on each predicate until one matches. If non-matches an exception is raised.

---- Examples ----
>>> -9 | match[
>>>     (Is[less_than[-10]], lambda x: f'it is a freezing {x} degrees'),
>>>     (Is[less_than[10]], lambda x: f'somewhat cold: {x} degrees'),
>>>     (Is[greater_than_or_equal[20]], lambda x: f'warm: {x}'),
>>>     (Any, lambda x: f'something else {x}'),
>>> ] | collect                            => 'somewhat cold: -9 degrees'

---- Arguments ----
item: the incoming value
patterns: (T, T) -> Bool

---- Signature ----
(T, (T->Any)) -> T

---- Tags ----
- used for: control flow
- used for: logic
- used for: function application
```

### MatchApply

```python
This is apply version of match operator. Where the pattern tuple's second item contains a function to be applied
on the inputed item.

---- Examples ----
>>> -9 | match[
>>>     (less_than[-10], add[10]),
>>>     (less_than[0], multiply[2]),
>>>     (greater_than_or_equal[0], add[1]),
>>> ] | collect                            => -18

---- Arguments ----
item: the incoming value
patterns: (T, T) -> Bool

---- Signature ----
(T, (T->Any)) -> T

---- Tags ----
- used for: control flow
- used for: logic
- used for: function application
```

### Sync

```python
Creates an effect to set the sync option on the graph. Defaults to enabling
sync (sync_state=True) but can be set to False to disable sync.

---- Examples ----
>>> g | sync | run
>>> g | sync[True] | run
>>> g | sync[False] | run

---- Signature ----
Graph -> Effect
(Graph, bool) -> Effect
```

### Tag

```python
Create an effect to add a tag to either a Graph or a RAE.

---- Examples ----
>>> g | tag["my_graph"] | run
>>> g2 | tag["my_graph"][True] | run
>>> z | tag["settings_node"] | g | run
>>> [z | tag["settings_node"]] | transact[g] | run

---- Arguments ----
x Graph / ZefRef: object to tag
tag str: the name of the tag to apply
force bool (=False): whether to allow stealing the tag from another graph or ZefRef.

---- Signature ----
(Graph, str, bool) -> Effect
(ZefRef, str, bool) -> LazyValue
```

### Untag

```python
Create an effect to remove a tag from either a Graph or a RAE

---- Examples ----
>>> g | untag["my_graph"] | run
>>> z | untag["settings_node"] | run

---- Signature ----
(Graph, str) -> Effect
(ZefRef, str) -> Effect
```

### ToClipboard

```python
A shortcut function to create an effect that will copy
an elementary type to the clipboard.

---- Examples ----
'hello' | to_clipboard                                  # returns an effect
my_zef_func | to_clipboard | run                        # copy a single zef function to the clipboard
g | now | all[ET.ZEF_Function] | to_clipboard | run     # copy all zef function on graph to clipboard

---- Signature ----
String                          -> Effect
Int                             -> Effect
Float                           -> Effect
Bool                            -> Effect
ZefRef[ET.ZEF_Function]         -> Effect
List[ZefRef[ET.ZEF_Function]]   -> Effect
```

### FromClipboard

```python
A shortcut function to create an effect that will request
the content of a clipboard to be copied
```

### TextArt

```python
convert a string to ascii art text
Todo: add flag to select comment style

---- Signature ----
String -> String
```

### ToJSON

```python
Serializes python types,zef types,ops, and custom types to a JSON dictionary

---- Examples ----
>>> zr | to_json | collect
>>> RT.A | to_json | collect

---- Signature ----
VT.Any -> VT.Dict
```

### FromJSON

```python
Deserializes a serialized object as a JSON dict back to the object.

---- Examples ----
>>> serialized_dict | from_json | collect

---- Signature ----
VT.Dict -> VT.Any
```

### ToYaml

```python
None
```

### FromYaml

```python
None
```

### ToToml

```python
None
```

### FromToml

```python
None
```

### ToCSV

```python
None
```

### FromCSV

```python
None
```

### ReadFile

```python
Reads the file at the given `fname` returning its content as bytes.

This operator produces an effect and must be passed to `run`. The output of
the effect will contain a "content" key with the file's content.

---- Examples ----
"data.yaml" | read_file | run | get["content"] | from_yaml | collect

---- Signature ----
VT.String -> VT.Effect
```

### LoadFile

```python
Reads the file at the given `fname` and parse its content based on the
file extension.

This operator produces an effect and must be passed to `run`. The output of
the effect will contain a "content" key with the transformed object.

---- Examples ----
"data.yaml" | load_file | run | get["content"] | collect

---- Signature ----
VT.String -> VT.Effect
```

### WriteFile

```python
The counterpart to `read_file`. Takes the given `content` and writes it to the file at the filename `fname`. The content is converted based on the extension of the file.

The options for content as described further in the `FX.LocalFile.Write` effect.

This operator doesn't do the writing itself, it only produces an effect
which must be passed to run.

---- Examples ----
"Hello" | write_file["data.txt"] | run

---- Signature ----
(VT.Any, VT.String) -> VT.Effect
```

### SaveFile

```python
The counterpart to `load_file`. Takes the given `content` and writes it to the file at the filename `fname`. The content is converted based on the extension of the file.

The options for content as described further in the `FX.LocalFile.Save` effect.

This operator doesn't do the writing itself, it only produces an effect
which must be passed to run.

Settings is used for cases where we would need to pass additional flags to the underlying conversion.
An example is for csv, we can pass a dict {"na_values": True} to keep NA values in the Pandas DF.

---- Examples ----
data_as_dict | save_file["data.yaml"] | run

---- Possible issues ---
data_as_dict | to_yaml | save_file["data.yaml"] | run
will create a yaml file containing a single string, which is unlikely to be
what you want.

---- Signature ----
(VT.Any, VT.String) -> VT.Effect
```

### PandasToGd

```python
Takes a pandas dataframe and a mapping Dict and returns a list of commands.

---- Signature ----
(VT.DataFrame,  VT.Dict) -> VT.List
```

### ToPipeline

```python
Given a list of operators, return one operator by constructing
an operator pipeline in that order.

---- Examples ----
>>> (nth[42], repeat, enumerate) | to_pipeline      # => nth[42] | repeat | enumerate

---- Tags ----
- used for: control flow
- operates on: ZefOps, Value Types, Entity, Relation, AtomicEntity, ZefRef, EZefRef
- related zefop: inject
- related zefop: inject_list
- related zefop: absorbed
- related zefop: without_absorbed
- related zefop: reverse_args
- related zefop: bypass
```

### Inject

```python
Small helper function to inject the inflowing data via [...]

---- Examples ----
>>> 42 | inject[equals]         # => equals[42]

---- Tags ----
- used for: control flow
- operates on: ZefOps, Value Types, Entity, Relation, AtomicEntity, ZefRef, EZefRef
- related zefop: inject_list
- related zefop: absorbed
- related zefop: without_absorbed
- related zefop: reverse_args
- related zefop: to_pipeline
```

### InjectList

```python
Small helper function to inject a list of inflowing data
as multiple [...][...]...

---- Examples ----
>>> [pred1, pred2, pred3] | inject[And]         # => And[pred1][pred2][pred3]

---- Tags ----
- used for: control flow
- operates on: ZefOps, Value Types, Entity, Relation, AtomicEntity, ZefRef, EZefRef
- related zefop: inject
- related zefop: absorbed
- related zefop: without_absorbed
- related zefop: reverse_args
- related zefop: to_pipeline
```

### ZasciiToAsg

```python
Takes a zascii string and returns an asg dict.

---- Signature ----
(VT.String) -> VT.Dict
```

### ZasciiToScehma

```python
Takes a zascii string with a schema and returns a GraphDelta.

---- Signature ----
(VT.String) -> VT.GraphDelta
```

### ReplaceAt

```python
Given a list replace element at an index with new_el.
Given a string return a new string with element at index replaced with new_el.

---- Signature ----
(VT.String, VT.Int, VT.String) -> VT.String
(VT.List, VT.Int, VT.Any) -> VT.List
```

### RandomPick

```python
Given a list, tuple, string: returns a random item from that iterable.
```

### PadToLength

```python
Pads a string with white space to the right to a specific length l.
```

### PadLeft

```python
Pads a string to a specified length by inserting
the pad_element on the left.
If the input string is longer than the specified
length, the original string is returned.
The pad_element is optional, with ' ' being the
default.

---- Examples ----
>>> 'hi' | pad_left[5]['.']      # => '...hi'
>>> 'hi' | pad_left[5]           # => '   hi'

---- Signature ----
String -> String

---- Tags ----
operates on: String
used for: string manipulation
related zefop: pad_right
related zefop: pad_center
related zefop: slice
```

### PadRight

```python
Pads a string to a specified length by inserting
the pad_element on the right.
If the input string is longer than the specified
length, the original string is returned.
The pad_element is optional, with ' ' being the
default.

---- Examples ----
>>> 'hi' | pad_right[5]['.']      # => 'hi...'
>>> 'hi' | pad_right[5]           # => 'hi   '

---- Signature ----
String -> String

---- Tags ----
operates on: String
used for: string manipulation
related zefop: pad_left
related zefop: pad_center
related zefop: slice
```

### PadCenter

```python
Pads a string to a specified length by inserting
the pad_element on both sides, equally.
If an odd number of pad_elements must be distributed,
one more is added to the left.
If the input string is longer than the specified
length, the original string is returned.
The pad_element is optional, with ' ' being the
default.

---- Examples ----
>>> 'hi' | pad_center[5]['.']      # => '..hi.'
>>> 'hi' | pad_center[5]           # => '  hi '

---- Signature ----
String -> String

---- Tags ----
operates on: String
used for: string manipulation
related zefop: pad_left
related zefop: pad_right
related zefop: slice
```

### Floor

```python
The mathematical floor function.
Rounds down to the next smallest integer.

---- Examples ----
>>> 5.1 | floor      # => 5
>>> 5.9 | floor      # => 5
>>> 5.0 | floor      # => 5

---- Signature ----
Float -> Int
Int -> Int

---- Tags ----
operates on: Float
used for: maths
related zefop: ceil
related zefop: round
```

### Ceil

```python
The mathematical ceil function.
Rounds down to the next biggest integer.

---- Examples ----
>>> 5.1 | ceil      # => 6
>>> 5.9 | ceil      # => 6
>>> 5.0 | ceil      # => 5

---- Signature ----
Float -> Int
Int -> Int

---- Tags ----
operates on: Float
used for: maths
related zefop: floor
related zefop: round
```

### Round

```python
The mathematical round function.
Rounds down to the next integer.

---- Examples ----
>>> 5.1 | round      # => 5
>>> 5.9 | round      # => 6
>>> 5.5 | round      # => 5
>>> 5.0 | round      # => 5

---- Signature ----
Float -> Int
Int -> Int

---- Tags ----
operates on: Float
used for: maths
related zefop: floor
related zefop: ceil
```

### IsAlpha

```python
Given a string return if it is only composed of Alphabet characters
```

### IsNumeric

```python
Given a string, determine if all characters are numeric, i.e. string
representations of integers.

---- Examples ----
>>> 'a' | is_numeric          # => False
>>> '4' | is_numeric          # => True
>>> '42' | is_numeric         # => True
>>> '42.6' | is_numeric       # => False

---- Signature ----
String -> Bool

---- Tags ----
- related zefop: is_alpha
- related zefop: is_alpha_numeric
- operates on: String
- used for: predicate function
```

### IsAlphaNumeric

```python
Given a string, determine if all characters are numeric or
alphabetical letters. Any special symbols or characters
would cause this function to return False.

---- Examples ----
>>> 'a' | is_alpha_numeric          # => True
>>> '4' | is_alpha_numeric          # => True
>>> '42abc' | is_alpha_numeric      # => True
>>> 'hello!' | is_alpha_numeric     # => False
>>> 'good morning' | is_alpha_numeric     # => False


---- Signature ----
String -> Bool

---- Tags ----
- related zefop: is_alpha
- related zefop: is_numeric
- operates on: String
- used for: predicate function
```

### ToUpperCase

```python
Given a string, capitalize each character.

---- Examples ----
>>> 'aBc' | to_upper_case          # => 'ABC'

---- Signature ----
VT.String -> VT.String

---- Tags ----
- related zefop: to_lower_case
- related zefop: to_pascal_case
- related zefop: to_camel_case
- related zefop: to_kebab_case
- related zefop: to_snake_case
- related zefop: to_screaming_snake_case
- operates on: String
- used for: string manipulation
```

### ToLowerCase

```python
Given a string, convert each character to lower case.

---- Examples ----
>>> 'aBc' | to_upper_case          # => 'abc'

---- Signature ----
VT.String -> VT.String


---- Tags ----
- related zefop: to_upper_case
- related zefop: to_pascal_case
- related zefop: to_camel_case
- related zefop: to_kebab_case
- related zefop: to_snake_case
- related zefop: to_screaming_snake_case
- operates on: String
- used for: string manipulation
```

### ToPascalCase

```python
Convert a string to PascalCase style. Uses the caseconverter module.

This is intended for use in producing variable names. It is also useful for
generating token (e.g. `ET` or `RT`) names.

---- Examples ----
>>> 'person_name' | to_pascal_case   # => "PersonName"
>>> 'jsObject' | to_pascal_case      # => "JsObject"
>>> 'external. data-with  UNUSUAL@characters' | to_pascal_case   # => "ExternalDataWithUnusualcharacters"

---- Signature ----
String -> String

---- Tags ----
- related zefop: to_lower_case
- related zefop: to_upper_case
- related zefop: to_camel_case
- related zefop: to_kebab_case
- related zefop: to_snake_case
- related zefop: to_screaming_snake_case
- operates on: String
- used for: string manipulation
```

### ToCamelCase

```python
Convert a string to camelCase style. Uses the caseconverter module.

This is intended for use in producing variable names.

---- Examples ----
>>> 'person_name' | to_camel_case   # => "personName"
>>> 'TokenName' | to_camel_case    # => "tokenName"
>>> 'external. data-with  UNUSUAL@characters' | to_camel_case   # => "externalDataWithUnusualcharacters"

---- Signature ----
String -> String

---- Tags ----
- related zefop: to_lower_case
- related zefop: to_upper_case
- related zefop: to_pascal_case
- related zefop: to_kebab_case
- related zefop: to_snake_case
- related zefop: to_screaming_snake_case
- operates on: String
- used for: string manipulation
```

### ToKebabCase

```python
Convert a string to kebab-case style. Uses the caseconverter module.

This is intended for use in producing variable names.

---- Examples ----
>>> 'person_name' | to_kebab_case   # => "person-name"
>>> 'TokenName' | to_kebab_case    # => "token-name"
>>> 'external. data-with  UNUSUAL@characters' | to_kebab_case   # => "external-data-with-unusualcharacters"

---- Signature ----
String -> String

---- Tags ----
- related zefop: to_lower_case
- related zefop: to_upper_case
- related zefop: to_pascal_case
- related zefop: to_camel_case
- related zefop: to_snake_case
- related zefop: to_screaming_snake_case
- operates on: String
- used for: string manipulation
```

### ToSnakeCase

```python
Convert a string to snake_case style. Uses the caseconverter module.

This is intended for use in producing variable names.

---- Examples ----
>>> 'yaml-keyword' | to_snake_case   # => "yaml_keyword"
>>> 'TokenName' | to_snake_case    # => "token_name"
>>> 'external. data-with  UNUSUAL@characters' | to_snake_case   # => "external_data_with_unusualcharacters"

---- Signature ----
String -> String

---- Tags ----
- related zefop: to_lower_case
- related zefop: to_upper_case
- related zefop: to_pascal_case
- related zefop: to_camel_case
- related zefop: to_kebab_case
- related zefop: to_screaming_snake_case
- operates on: String
- used for: string manipulation
```

### ToScreamingSnakeCase

```python
Convert a string to SCREAMING_SNAKE_CASE style. Uses the caseconverter module.

This is intended for use in producing variable names.

---- Examples ----
>>> 'yaml-keyword' | to_screaming_snake_case   # => "YAML_KEYWORD"
>>> 'TokenName' | to_screaming_snake_case    # => "TOKEN_NAME"
>>> 'external. data-with  UNUSUAL@characters' | to_screaming_snake_case   # => "EXTERNAL_DATA_WITH_UNUSUALCHARACTERS"

---- Signature ----
String -> String

---- Tags ----
- related zefop: to_lower_case
- related zefop: to_upper_case
- related zefop: to_pascal_case
- related zefop: to_camel_case
- related zefop: to_kebab_case
- related zefop: to_snake_case
- operates on: String
- used for: string manipulation
```

### Call

```python
None
```

### Unpack

```python
None
```

### MakeRequest

```python
None
```

### Blake3

```python
None
```

### ToZefList

```python
None
```

### Transact

```python
None
```

### Function

```python
func_repr is of form (int, any)
where the first integer encodes how the function is
represented in the ZefOp:
-------- representation types -------
0) Abstract Entity
1) captured python lambda or local function
```

### On

```python
Create an event stream based on the event type declared
in the parameters. This function itself is impure! It sets
up a concrete stream and a callback listening for events
on a graph.

The returned Streams do not contain dicts, but the events
expressed as ZefOps. Why? The Zef query syntax is built
upon predicate logic and the events in the stream are in
this very language and represent positive clauses, i.e.
state facts about what happened. For example,
"instantiated[z1]" is an assertion / account of the fact
that the entity referenced by z1 occurred. The reference
frame of z1 contains the time at which the logical thread
of that frame learned about that fact.

This function is pure, it returns an abstract stream. The
program state is only changed and all is hooked up on the
dataflow graph once an impure functions subscribes at
the very end.

---- Examples ----
>>> g | on[value_assigned[AET.String]]              # value_assigned[z3]['hello!']      c.f. with action: assign_value[z3]['hello!']
>>> g | on[terminated[z2]]                          # terminated[z2], followed by completion_event
>>> g | on[instantiated[ET.Foo]]                    # instantiated[z5]
>>>
>>> # listening for new relations
>>> # old syntax:  zz | subscribe[on_instantiation[outgoing][RT.Foo]][my_callback]       old syntax
>>> g | on[ instantiated[(zz, RT.Foo, Z)] ]         # Z matches on anything, i.e. takes on role of "_"
>>>
>>> One can also add more precise requirements
>>> g | on[ instantiated[(zz, RT.Foo, ET.Bar)] ]    # an element "instantiated[z_rel]" is pushed into the stream. Instances are represented by a single ZefRef, types by a triple for relations
>>> g | on[ terminated[(zz, RT.Foo, Z)] ]
>>>
>>> g | on[terminated[z_rel]]

---- Signature ----
(Graph, ZefOp[ValueAssigned]) -> Stream[ZefOp[ValueAssigned[ZefRef][Any]]]
(Graph, ZefOp[Instantiated]) -> Stream[ZefOp[Instantiated[ZefRef]]]
(Graph, ZefOp[Terminated]) -> Stream[ZefOp[Terminated[ZefRef]]]

...
```

### Range

```python
None
```

### ZstandardCompress

```python
Compress a Bytes value using ZStandard.
The compression level can be specified optionally.

---- Example ----
>>> 'hello' | to_bytes | zstandard_compress

---- Signature ----
Bytes -> Bytes

---- Tags ----
used for: data compression
operates on: Bytes
related zefop: zstandard_compress
```

### ZstandardDecompress

```python
Decompress a Bytes value using ZStandard.

---- Example ----
>>> 'hello' | to_bytes | zstandard_compress | zstandard_decompress

---- Signature ----
Bytes -> Bytes

---- Tags ----
used for: data compression
operates on: Bytes
related zefop: zstandard_decompress
```

### ToBytes

```python
Convert a string to a ValueType Bytes using utf8 encoding.
Python bytes are wrapped and Bytes are forwarded.

---- Example ----
>>> 'hello' | bytes_to_base64string     # equivalent to Bytes(b'hello')

---- Signature ----
String | Bytes -> Bytes

---- Tags ----
used for: type conversion
operates on: String
```

### Utf8bytesToString

```python
Convert a Byes value that is a utf8 encoded string,
return the string. Not all bytes values are valid utf8.


---- Example ----
>>> 'hello' | to_bytes | utf8bytes_to_string     # => 'hello'

---- Signature ----
Bytes -> String | Error

---- Tags ----
used for: type conversion
operates on: Bytes
```

### Base64stringToBytes

```python
Convert data that is in a valid base64 encoding as a string to bytes.
Not all strings are valid base64 encoded strings.
Returns the decoded Bytes object

---- Example ----
>>> 'hello' | bytes_to_base64string

---- Signature ----
String | Bytes -> Bytes

---- Tags ----
used for: type conversion
operates on: String
```

### BytesToBase64string

```python
Convert any bytes object into a base64 encoded string.

---- Example ----
>>> b'hello' | bytes_to_base64string

---- Signature ----
Bytes -> String

---- Tags ----
used for: type conversion
operates on: Bytes
```

### IsBetween

```python
Checks whether a specified value lies within the
specified range for some orderable data type.
Like the SQL counterpart, this operator is INCLUSIVE.

---- Examples ----
>>> 5 | is_between[1][9]     # => True
>>> 42 | is_between[1][9]    # => False
>>> 9 | is_between[1][9]     # => True

---- Signature ----
Tuple[List[T], T, T] -> Bool

---- Tags ----
used for: logic
used for: maths
operates on: List[Int]
operates on: List[Float]
operates on: List[QuantityInt]
operates on: List[QuantityFloat]
```

### If

```python
Dispatches to one of two provided functions based on the boolean
result of the predicate function wrapped as a logic type, given
the input value.
The input value into the zefop is used by the predicate and
forwarded to the relevant case function.

---- Examples ----
>>> Evens = Is[modulus[2] | equals[0]]
>>> 4 | If[ Evens ][add[1]][add[2]]            # => 5

---- Signature ----
((T->Bool), (T->T1), (T->T2)) -> Union[T1, T2]

---- Tags ----
- used for: control flow
- used for: logic
- related zefop: if_then_else
- related zefop: group_by
- related zefop: match
- related zefop: match_apply
- related zefop: filter
```

### Privileges

```python
None
```

### Config

```python
None
```

### TakeTransactorRole

```python
None
```

### ReleaseTransactorRole

```python
None
```

### HaveTransactorRole

```python
None
```
