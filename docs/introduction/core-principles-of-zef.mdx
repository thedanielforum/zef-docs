---
id: core-principles-of-zef
title: ❗️Core Principles of Zef
---

## Everything is just data

## Flat is better than nested

## Don't mutate data

## Treat time as a first class citizen

## Subscribe, stream, and collaborate in real-time

## Work close to your data

## Abstract away database and backend overhead

<!---
### It's just data
Keeping state separated from the compute that operates on it is a principle that most experienced programmers who have worked on complex projects can agree on. A zefDB graph is a highly versatile and flexible data structure where one can keep all of that state.

### The ontological rule of zef
The more complex your project grows, the more you realize that the data structure you should have used to model the real world is a graph. 


### If in doubt, go granular
This is another way of expressing the "Zen of Python" rule "Flat is better than nested". We often found ourselves refactoring our state layout: Should a given thing be a field/property (nested) of a node on a property graph or should we make it a separate node. After doing this N+1 times where N is too many, we decided to try out something radically different. 

**No properties, no nesting whatsoever in our data structure. Ever! Extreme flatness and no structurally imposed hierarchy. The ontological anarchist's dream.**

 We did this after noticing that our refactorings were *always* a one way street. It was always breaking down a more nested data structure into a less nested one. It was always making something that was a field a separate thing, because some completely different part of our model needed to refer to it on the graph.

 Never did we think in retrospect: "this thing that we modeled as a separate node should actually have been a field.



### Ontological hierarchies are in the eye of the beholder
A certain order of nesting fields may make a lot of sense when implementing it in one context. But when accessing the very same data in a different context a few weeks later when solving a different problem, one often notices an impedance mismatch of the originally chosen data layout with the new problem. Often one seeks the perfect nested data layout fulfilling various constraints in a larger project and justifies the conflicting requirements with "engineering is always about tradeoffs". Sometimes no tradeoffs need to be made once one recognizes that the underlying problem is that the problem domain is isomorphic to a graph with cross-connections and not a tree. 

Choosing nested structs (or equivalently nested dictionaries, object, ...) inherently couples data layout to ontology. This may often be the easiest and best thing to do for simple domains that map well onto a tree. But it is important to realize that using a tree structure to model real world relations is a choice, albeit one that is so common than many a programmer doesn't even consider asking whether a nested set of structs is the right data type for the problem.


### Don't mutate your critical data
Self evident.


### No separate query language, rather a DSL library
The architectural pattern is completely different from most other databases. There is no *database server*. zefDB is designed as a relativistic distributed information management system from the very core. You don't send a query to a server and get an answer back that you need to validate, unpack into local data strcutures etc.
The data that you are interested in (subpart of a graph) is simply copied into your memory and you can query it in whichever way you want. Why would you need a separate query language, rather than just taking the very language you are working with in any case? zefDB as a library provides you a plethora of functions and composable operators that can be used together with all other existing languages constructs, libraries in the very code that you are writing.



### Why do have the database ↔ internal data structures dichotomy?

Especially in retrospect, we actually do not know the answer to this question. Possible reasons someone may bring up (please feel free to propose others)
1. performance
2. our programming language tools are not as good as e.g. SQL to efficiently get the information we want in a complex domain
3. happenstance
4. high storage cost compared to ephemeral in-memory structures

We don't actually k

The more we thin


## Goals & Positioning
* 
* fully embrace parallelism and distributed computing. Separating data from compute and making the core data immutable allows for safe sharing between threads and processes
* zefDB inter-process communication should be written lock-free. Try to escape Amdahl's law. Using atomics on shared memory (zefDB uses mmap) should be possible, even across processes:
> 29.4: [Note: Operations that are lock-free should also be address-free. That is, atomic operations on the same memory location via two diﬀerent addresses will communicate atomically. The implementation should not depend on any per-process state. This restriction enables communication by memory that is mapped into a process more than once and by memory that is shared between two processes. —end note] 


## Key Features
- **Support for Python, C++, Julia**: Depending on need, more coming in the future.
- **No separate query language**: Build queries using your programming language of choice (and copy/paste it to others, even if they're using a different language). See an example here.
- **Time versioning built-in**: Immutable, append-only data structures mean all change history is automatically captured and catalogued across time.
- **Model complex relationships**: Create an edge on an edge...then add another edge if needed.
- **Clear graph ownership and view permissions**: Distinguish permissions and reassign new owners or views on the fly.
- **Share graphs with a single link**: Share instant access to your graph by messaging its UID via Slack, WhatsApp, or any other messaging platform. See an example here.
- **Collaborate in real-time**: Take a graph UID and stream others' changes instantly in real-time.
--->