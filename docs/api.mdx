---
id: api
title: zefOps
author: Ulf,Simon
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


## Host Language Types

### Graph

:::type `Graph`
Container for all Zef objects.

[TODO: Clarify the precise semantics of `Graph()`]
:::

:::function `Graph(sync::Bool = false)`
Create a new graph, synced with ZefHub if `sync == true`.
:::

:::function `Graph(tag::String)`
Download the specified graph from ZefHub.
:::

:::function `Graph(a::ZefRef)`
Extract a reference to the graph of `a`.
:::


### ZefRef

:::type `ZefRef`

Version-aware reference to a Zef object.

You may think of a `ZefRef` as a pair `(e,t)`, where `e` is a pointer to a "timeless" Zef object (see [`UZefRef`](#uzefref)), and `t` indicates the time slice at which this object is viewed.

This documentation writes `ZefRef<zef_type>` to denote a `ZefRef` to an object of of the given [`zef_type`](#zef-types).

The result of a ZefOp of the form `ZefRef -> ZefRef` is at the same time slice unless you explicitly ask for time travel.

**Example**

```python
g = Graph()
a = instantiate(ET.A,g)
b = instantiate(ET.B,g)
instantiate(a,RT.E,b,g)

a | tx | time_slice  # -> TimeSlice(1)
a | now | tx | time_slice  # -> TimeSlice(3)
(a|now) >> RT.E | tx | time_slice  # -> TimeSlice(3)
```
:::



### ZefRefs

:::type `ZefRefs`

List of `ZefRef`s, all of which are at the same time slice.

You may think of a `ZefRefs` as a pair `(e,t)`, where `e` is a vector of pointers to "timeless" Zef objects (see [`UZefRefs`](#uzefrefs)), and `t` indicates the time slice at which these objects are viewed.

**Example**
```python
g = Graph()
a = instantiate(ET.A,g)
b = instantiate(ET.B,g)

ZefRefs(a,b)  # ERROR: a and b are at different time slices
ZefRefs(a|now,b|now)  # Do this instead
```
:::


### UZefRef

:::type `UZefRef`

Version-unaware reference to a Zef object.

Unlike [`ZefRef`](#zefref), `UZefRef`s do not come with a reference transaction and hence their behaviour differs in several important aspects:
- `ZefRef`s filter relations based on whether they are visible at the reference transaction (i.e. whether they have been instantiated before the reference transaction and terminated after the reference transaction). `UZefRef`s consider any relation which has ever been attached to the object in question.
- You cannot have a `ZefRef` to a terminated Zef object, but you can have a `UZefRef` to such an object.
- You cannot take the value of a `UZefRef<AET>`. Instead, you must convert to a `ZefRef` using e.g. `uzefref | now`.
:::


### UZefRefs

:::type `UZefRefs`

Vector of [`UZefRef`s](#uzefref).

This type is equivalent to any other container-of-`UZefRef`s type (e.g. the generic vector type provided by your programming language) except that ZefOps of the form `UZefRef -> Anything` applied to a `UZefRefs` are automatically lifted to apply to each element.
:::

### QuantityFloat, QuantityInt

:::type `QuantityFloat`
Floating-point number with a physical unit (e.g. `EN.Unit.seconds`).

**Example**
```python
g = Graph()
a = instantiate(AET.QuantityFloat.seconds, g)
a <= QuantityFloat(1.0, EN.Unit.seconds)
```
:::

:::type `QuantityInt`
Analogous to `QuantityFloat`.
:::

:::function `unit_strip(unit, q::QuantityFloat)`
Check that `q` is a `QuantityFloat` with the given `unit` and return its value as a vanilla floating-point number.

**Example**
```python
unit_strip(EN.Unit.seconds, 5*seconds) # <- 5.0
```
:::

:::function `unit_strip(unit, q::QuantityInt) -> [default int type of your language]`
Check that `q` is a `QuantityInt` with the given `unit` and return its value as a vanilla integer.
:::

:::type `EN.Unit.<unitname>`
Zef representation of the physical unit `<unitname>` (e.g. `seconds`, `kilograms`, etc.).
:::


## Zef Types

### RAE Types (`RT`, `AET`, `ET`)

:::zeftype `AET.<typename>`
Atomic entity type. AET Zef objects can hold a single value of the indicated type.

`<typename>` must be one of `Bool`, `Int`, `Float`, `Time`, `QuantityInt.<unit>` or `QuantityFloat.<unit>`, where `<unit>` denotes a physical unit (e.g. `seconds`).

**Example**

```python
g = Graph()
a = instantiate(AET.Bool,g)
a <= true
a | now | value # <- true
```
:::

:::zeftype `ET.<typename>`
Entity type, serving to distinguish structurally equivalent Zef entities.

`<typename>` can be any valid symbol in your programming language (e.g. `ET.WhateverYouWant`).
:::

:::zeftype `RT.<typename>`
Relation type, serving to distinguish structurally equivalent relations between Zef objects.

`<typename>` can be any valid symbol in your programming language (e.g. `RT.WhateverYouWant`).

**Example**
```python
g = Graph()
a = instantiate(ET.A,g)
b = instantiate(ET.B,g)
e = instantiate(a,RT.E,b,g)
f = instantiate(a,RT.F,b,g)

a | now | outs # <- ZefRefs(e|now,f|now), i.e. all outgoing relations
a > L[RT.E]    # <- ZefRefs(e|now), i.e. only the outgoing relations of type RT.E
```
:::


### Transaction Type `TX`

:::zeftype `TX`
Zef transaction objects. Not to be confused with the transaction utility class [`Transaction(g)`](#transaction).
:::


## Piping (`|`) and Currying (`[]`)

[TODO: This probably shouldn't be in the API section]

Many ZefDB queries amount to applying a large number of nested functions to a
single `(U)ZefRef(s)`. For example, the node on the other end of the first
outgoing relation of a given `node` can be obtained through
```python
target(first(outs(node)))
```
Unfortunately, the traditional `fun(arg)` syntax becomes hard to read once the
number of nested functions becomes too large.  To avoid parentheses hell, ZefDB
overloads `|` as a [piping
operator](https://en.wikipedia.org/wiki/Vertical_bar#Pipe) such that the above
expression can be written as
```python
node | outs | first | target
```
This syntax makes a long chain of one-argument functions much easier to read,
but it requires one more twist to be able to handle functions of several
arguments. This twist is known as
[currying](https://en.wikipedia.org/wiki/Currying), and in ZefDB it takes the
following form:
```python
function_name[one_or_more][other_arguments](main_argument)
```
For example, if instead of the first of any outgoing relations we wanted the first outgoing relation of type `RT.Relation`, then we'd have to replace the above command with
```python
node | outs | filter[RT.Relation] | first | target
```

## Graph Construction

### instantiate

:::function `instantiate(et::ET+AET, ::Graph) -> ZefRef<et>`

Instantiate a new entity with the given ET or AET type.
Returns a `ZefRef` to the newly created object.

**Example**

```python
g = Graph()
a = instantiate(ET.Node,g)  # <- ZefRef to a newly created ET.Node at time slice 1
```
:::


:::function `instantiate(a::ZefRef, rt::RT, b::ZefRef, ::Graph) -> ZefRef<rt>`

Instantiate a new relation of type `rt` from `a` to `b`.  Returns a `ZefRef` to the newly created object.

**Example**

```python
g = Graph()
a = instantiate(ET.A,g)
b = instantiate(ET.B,g)
e = instantiate(a,RT.Edge,b,g)
# ^ ZefRef to a newly created RT.Edge from a to b at time slice 3
```
:::

### terminate

:::function `terminate(a::ZefRef)`

Terminate the indicated Zef object.
Terminating an object automatically terminates all connected
relations.

**Example**

```python
g = Graph()
a = instantiate(ET.A,g)
b = instantiate(ET.B,g)
e = instantiate(a,RT.E,b,g)
terminate(b)

b | now  # <- ERROR: Cannot have a ZefRef to a terminated object.

# Terminating b also terminates e:
a | now | time_travel[-1] | has_out[RT.E]  # <- True
a | now | time_travel[ 0] | has_out[RT.E]  # <- False
```
:::


### Transaction

:::type `Transaction(g)`

Group several Zef operations into a single transaction.

The precise syntax for this construct is language-dependent; see the examples below.

Transactions can be arbitrarily nested with the effect that all but the outermost transaction are ignored. The transaction construct therefore guarantees that all operations within its body appear in the same transaction, but it does not exclude other operations from being merged into the same transaction.

`ZefRef`s returned from `instantiate()` have the current transaction as their time slice and hence they do reflect changes introduced after instantiation.

<Tabs
  groupId="programming-languages"
  defaultValue="py"
  values={[
    { label: 'Python', value: 'py', },
    { label: 'C++', value: 'cpp', },
    { label: 'Julia', value: 'jl', },
  ]
}>
<TabItem value="py">

```python
g = Graph()
with Transaction(g):
    a = instantiate(ET.A,g)
    with Transaction(g): # <- Nested transactions are ignored
        b = instantiate(ET.b,g)
        e = instantiate(a,RT.E,b,g)
    print(a | outs)
    # ^ ZefRefs(e) since a and e have been instantiated in the same transaction

print(a | tx | time_slice)  # <- <TimeSlice: 1>
print(b | tx | time_slice)  # <- <TimeSlice: 1>
print(e | tx | time_slice)  # <- <TimeSlice: 1>
# ^ Same time slice because a,b and e have been created in the same transaction.
```

</TabItem>
<TabItem value="cpp">

```cpp
// --------------------------------------
// Warning: this code has not been tested
// --------------------------------------

Graph g;
ZefRef a,b,e;
{Transaction tx(g);  // <- Using RAII
    a = instantiate(ET.A,g);
    {Transaction tx(g); // <- Nested transactions are ignored
        b = instantiate(ET.B,g);
        e = instantiate(a,ET.,g);
    }
    std::cout << (a | outs) << std::endl;
    // ^ ZefRefs(e) since a and e have been instantiated in the same transaction
}

std::cout << (a | tx | time_slice) << std::endl;  // <- <TimeSlice: 1>
std::cout << (b | tx | time_slice) << std::endl;  // <- <TimeSlice: 1>
std::cout << (e | tx | time_slice) << std::endl;  // <- <TimeSlice: 1>
// ^ Same time slice because a,b and e have been created in the same transaction.
```

</TabItem>
<TabItem value="jl">

```julia
g = Graph()
a,b,e = Transaction(g) do
    a = instantiate(ET.A,g)
    b,e = Transaction(g) do  # <- Nested transactions are ignored
        b = instantiate(ET.b,g)
        e = instantiate(a,RT.E,b,g)
        return b,e
    end
    println(a | outs) # <- ZefRefs(e) since a and e have been instantiated in the same transaction
    return a,b,e
end

println(a | tx | time_slice)  # <- TimeSlice(1)
println(b | tx | time_slice)  # <- TimeSlice(1)
println(e | tx | time_slice)  # <- TimeSlice(1)
# ^ Same time slice because a,b and e have been created in the same transaction.
```

</TabItem>
</Tabs>
:::


### Value Assignment (`<=`)

:::function `<=(a::ZefRef<AET.T>, x::T) where T <: AET`

Assign value `x` to the atomic entity `a`.

**Example**

```python
g = Graph()
a = instantiate(AET.String,g)
a <= "Hello world!"
```
:::


### attach

:::function `attach[rt,b](a::ZefRef) -> a|now`

Instantiate a relation of type `rt` from `a` to `b`.

`b` can be any of the following:
 - A `ZefRef`.
 - An `AET` type. This will attach a newly instantiated, uninitialized AET of the indicated type.
 - An `AET` value. This will attach a newly instantiated AET initialized with the given value.

**Example**

```python
g = Graph()
a = (
    instantiate(ET.Node, g)
    | attach[RT.A, instantiate(ET.Node, g)]
    | attach[RT.B, AET.String]
    | attach[RT.C, "hello world"]
)
```
:::

:::function `attach[rtb::Vector](a::ZefRef) -> a | now`

Attach multiple entities in a single transaction, i.e. do the following:

<Tabs
  groupId="programming-languages"
  defaultValue="py"
  values={[
    { label: 'Python', value: 'py', },
    { label: 'Julia', value: 'jl', },
  ]
}>
<TabItem value="py">

```python
with Transaction(Graph(a)):
    for (rt,b) in rtb:
        a | attach[rt,b]
```

</TabItem>
<TabItem value="jl">

```julia
Transaction(Graph(a)) do
    for (rt,b) in rtb
        a | attach[rt,b]
    end
end
```

</TabItem>
</Tabs>

**Example**

```python
g = Graph()
a = (
    instantiate(ET.Node, g)
    | attach[[(RT.A,0),(RT.B,0)]]
)
a >> RT.A | instantiation_tx | time_slice  # <- TimeSlice(2)
b >> RT.B | instantiation_tx | time_slice  # <- TimeSlice(2)
```
:::




### tag

:::function `tag(a::ZefRef, t::String)`

Tag `a` with tag `t` so it can be looked up using [`graph[t]`](#graph-subscript-operator).

This function will throw an error if you attempt to tag an object `a` with the UID of a different object `b`.

**Example**

```python
g = Graph()
a = instantiate(ET.Node, g)
tag(a, "a")
g["a"] == a | to_uzefref  # <- true
```
:::

:::function `tag(g::Graph, t::String; force = false, adding = true)`

Tag graph `g` so it can be loaded using [`Graph(t)`](#graph).

Tags are automatically synced with ZefHub, thus tagging a graph on one process makes it available everywhere.

If the given tag has already been assigned to a different graph, then `tag(g,t, force=false)` will throw an error while `tag(g,t, force=true)` will steal the tag from the other graph.

`tag(g,t, adding = false)` removes the given tag instead of adding it.

**Example**

```python
g1 = Graph(true)
tag(g1, "hello world")
g2 = Graph("hello world")
# g1 and g2 are now references to the same graph object
```
:::


### clone

:::function `clone(g::Graph) -> Graph`

Create a deep clone of `g`.

The clone is structurally identical to `g` but its internal state is fully separate from that of the original. In particular, any change to the clone has no impact on the original graph.

**Note:** The UIDs of the entities in the cloned graph do not agree with those in the original.

**Example**

```python
g1 = Graph()
a1 = instantiate(AET.String, g1) <= "Hello"

g2 = clone(g1)
a2 = g2[AET.String] | only
a2 <= "Bye"

a1 | now | value  # <- "Hello"
a2 | now | value  # <- "Bye"
```
:::


### merge

:::function `merge(a::ZefRef+ZefRefs, g::Graph) -> ZefRefs`

Merge the given Zef object(s) into `g` and return a `ZefRefs` to the copies in `g`.

"Merging a Zef object `o` into `g`" amounts to the following:
 - If no time slice of `o` has been merged into `g` before, then instantiate an object of the same RAE type as `o`.
 - In either case, denote by `c` the clone of `o` which was created during the first merge.
 - Clone the current value of `o` into `c`. For ETs and RTs, the "current value" of `o` amounts to its termination status. For AETs, the "current value" additionally includes its AET value.

Unlike most other mutating functions, `merge()` allows you to mutate a graph even if you do not have primary role on it (but you do need write access).
`merge()` then proceeds by sending a merge request to the process with primary role, hence it will fail if no process has primary role or if the primary-role process does not have read access to `Graph(a)`.
You may use [`expose_to()`](#expose_to) to (temporarily) grant read access to a particular ZefHub user.

**Note:** You must use the `merge(a,tx,g)` version of this function if any element of `a` no longer exists in the given time slice.

**Example**

```python
g1 = Graph()
a1 = instantiate(AET.String, g1)
a1 <= "hello"

g2 = Graph()
a2 = merge(a1|now,g2) | only
a2 <= "bye"
merge(a2|now, g1)

a1 | now | value # <- "bye"
```
:::

:::function `merge(a::UZefRef+UZefRefs, tx::ZefRef<TX>, g::Graph)`
Like `merge(a::ZefRefs,g)`, but allows you to pass the reference transaction as a separate argument.
You must use this method to merge terminated Zef objects.
:::


## ZefHub Integration

### expose_to

:::function `expose_to(g::Graph, user::String)`
Allow `user` to view the given graph.

`expose_to(g,user)` can also be used to grant read access only temporarily using the following language-specific syntax:

<Tabs
  groupId="programming-languages"
  defaultValue="py"
  values={[
    { label: 'Python', value: 'py', },
    { label: 'Julia', value: 'jl', },
  ]
}>
<TabItem value="py">

```python
with expose_to(g::Graph, user::String)
```

Allow `user` to view the given graph for the duration of the context.

</TabItem>

<TabItem value="jl">

```julia
expose_to(f, g::Graph, user::String)
```

Call the zero-argument function `f()` and allow `user` to view `g` for the duration of the function call.

</TabItem>
</Tabs>

:::



### make_primary

:::function `make_primary(g::Graph)`

Assume primary role on graph `g`, i.e. give the current process exclusive write access.

`make_primary(g)` will fail if another process has already claimed primary role on `g`.
:::


## Graph Traversal

### instances

:::function `instances[t::ZefRef<TX>][et::ET+AET](g) -> ZefRefs<et>`

List all instances of type `et` at time `t`.

**Example**

```python
g = Graph()
for i in range(3):
    instantiate(ET.A,g)
for i in range(2):
    instantiate(ET.B,g)

g | instances[now][ET.A]  # <- ZefRefs<ET.A> of length 3
```
:::


### ins / outs / ins_and_outs

:::function `ins(a::ZefRef) -> ZefRefs<RT>`
All incoming relations of `a`.
:::

:::function `outs(a::ZefRef) -> ZefRefs<RT>`
All outgoing relations of `a`.
:::

:::function `ins_and_outs(a::ZefRef) -> ZefRefs<RT>`
All incoming and outgoing relations of `a`.
:::

:::function `has_in[rt::RT](a::ZefRef) -> Bool`
Check whether `a` has an incoming relation of type `rt`.
:::

:::function `has_out[rt::RT](a::ZefRef) -> Bool`
Check whether `a` has an outgoing relation of type `rt`.
:::

:::function `source(r::ZefRef<RT>) -> ZefRef`
Source of the relation `r`.
:::

:::function `target(r::ZefRef<RT>) -> ZefRef`
Target of the relation `r`.
:::

### relation and has_relation

:::function `relation(a::ZefRef, [rt::RT,] b::ZefRef)`

The unique relation (of type `rt`) from `a` to `b`.

**Example**

```python
g = Graph()
a = instantiate(ET.A,g)
b = instantiate(ET.B,g)
e1 = instantiate(a,RT.E1,b,g)
e2 = instantiate(a,RT.E2,b,g)

relation(a|now, b|now)  # <- ERROR: two relations from a to b
relation(a|now, RT.E1, b|now)  # <- e1 | now
```
:::

:::function `has_relation(a::ZefRef, [rt::RT,] b::ZefRef) -> Bool`
Check whether there exits one or more relations (of type `rt`) from `a` to `b`.

**Example**
```python
g = Graph()
a = instantiate(ET.A,g)
b = instantiate(ET.B,g)
e = instantiate(a,RT.E,b,g)

has_relation(a|now, b|now)  # <- true
has_relation(a|now, RT.E, b|now)  # <- true
has_relation(b|now, a|now)  # <- false. Relations are directed
```
:::


### to_zefref / to_uzefref

:::function `to_zefref[tx::ZefRef<TX>](a::UZefRef) -> ZefRef`
Convert the given `UZefRef` to a `ZefRef` at time slice `tx`.
:::

:::function `to_uzefref(a::ZefRef) -> UZefRef`
Strip the given `ZefRef` of its time slice information.
:::


### Traversal Operators `>`, `<`

:::function `>(a::ZefRef,rt::RT) -> ZefRef<rt>`
Get the relation of type `rt` starting in `a`.
Assumes there is exactly one such relation unless you use the [`L`](#l-operator) or [`O`](#o-operators) operators.

**Example**

```python
g = Graph()
a = instantiate(ET.A,g)
b = instantiate(ET.B,g)
e = instantiate(a,RT.E,b,g)

(a|now) > RT.E  # <- e
(b|now) < RT.E  # <- e
```
:::

:::function `<(a::ZefRef,rt::RT) -> ZefRef<rt>`
Get the relation of type `rt` ending in `a`. See `>(a,rt)` for more details.
:::


### Traversal Operators `>>`, `<<`

:::function `>>(a::ZefRef,rt::RT) -> ZefRef`

Get the target object of the relation of type `rt` starting in `a`.
Assumes there is exactly one such relation unless you use the [`L`](#l-operator) or [`O`](#o-operators) operators.

**Example**

```python
g = Graph()
a = instantiate(ET.A,g)
b = instantiate(ET.B,g)
e = instantiate(a,RT.E,b,g)

(a|now) >> RT.E  # <- b|now
(b|now) << RT.E  # <- a|now
```
:::

:::function `<<(a::ZefRef,rt::RT) -> ZefRef`
Get the source object of the relation of type `rt` ending in `a`.
See `>>(a,rt)` for more details.
:::


### `L` and `O` Operators

:::function `L[rt::RT]`

Indicate that there may be zero or more relations of type `rt` attached to the Zef object under consideration.
This construct is only meaningful in connection with a graph traversal operator (i.e. `>`, `<`, `>>` or `<<`), see the example below.

**Example**

```python
g = Graph()
a = instantiate(ET.A,g)
e1 = instantiate(a,RT.E,instantiate(RT.B,g),g)
e2 = instantiate(a,RT.E,instantiate(RT.B,g),g)

(a|now) >> RT.E  # <- ERROR: More than one outgoing RT.E
(a|now) >> L[RT.E]  # <- ZefRefs containing e1 and e2
```
:::

:::function `O[rt::RT]`
Indicate that there may or may not be a relations of type `rt` attached to the Zef object under consideration.
This construct is only meaningful in connection with a graph traversal operator (i.e. `>`, `<`, `>>` or `<<`), see the example below.

**Example**

```python
g = Graph()
a = instantiate(ET.A,g)
e = instantiate(a,RT.E,instantiate(RT.B,g),g)

a >> RT.E  # <- ERROR: a has no outgoing relations at the time of creation
a >> O[RT.E]  # <- nothing
(a|now) >> O[RT.E]  # <- e
```
:::


### value

:::function `value(a::ZefRef<AET.T>) -> T where T`

Extract the value of an atomic entity.

**Example**

```python
g = Graph()
a = instantiate(AET.String,g)
a <= "Hello world!"

a | value  # <- ERROR: a does not have a value at time of creation
a | now | value  # <- "Hello world!"
```
:::

:::function `value.T(a::ZefRef<AET.T>) -> T where T`

Extract the value of an atomic entity of type `T`.

The benefit of `value.T(a)` over `value(a)` is that the return type of `value.T(a)` is known at compile time.
This is required in C++ and avoids type instabilities in Julia.

**Example**

```python
g = Graph()
a = instantiate(AET.String,g)
a <= "Hello world!"

a | now | value.Int  # <- ERROR: a is an AET.String, not an AET.Int
a | now | value.String  # <- "Hello world!"
```
:::


### uid

:::function `uid(z::ZefRef) -> String`
The 128-bit unique identifier of `z` as a 32-character hex string.

The purpose of UIDs is to provide a process-independent means for identifying Zef objects. That is, if you have the same graph `g` checked out on two different processes, then `g[uid]` is guaranteed to refer to the same object.
This is in contrast to `ZefRef`s, which are only meaningful within the context of a single process.

**Note:**
Neither [`clone()`](#clone) nor [`merge()`](#merge) preserve UIDs.
:::


### Graph subscript operator

:::function `(g::Graph)[tag_or_uid::String] -> UZefRef`

`UZefRef` to the object with the given tag or UID.

Using the same function signature for looking up tags and UIDs is unambiguous because [`tag()`](#tag) will fail when you attempt to assign the UID of an object `a` to a different object `b`.

**Example**

```python
g = Graph()
a = instantiate(ET.Node, g)
g[a|uid] == a | to_uzefref  # <- true
```

```python
g = Graph()
a = instantiate(ET.Node, g)
tag(a, "a")
g["a"] == a | to_uzefref  # <- true
```
:::

:::function `(g::Graph)[rae_type::RT+AET+ET] -> UZefRefs<rae_type>`

All objects of the given RAE type.

**Example**

```python
g = Graph()
a = [instantiate(ET.A,g) for k = 1:5]
g[ET.A]  # <- UZefRefs to all entities in a
```
:::


## Container Utilities

### filter

:::function `filter[predicate](a::ZefRefs) -> ZefRefs`

Create a new `ZefRefs` with only those entries of `a` for which `predicate(a[k])` returns true.

**Example**
```python
g = Graph()
for i in range(10):
    v = instantiate(AET.Int,g)
    v <= i

(
    g | instances[now][AET.Int]
      | filter[lambda x: value(x) % 2 == 0]
) # ^ ZefRefs of length 5
```
:::

:::function ` filter[t::RT+ET](a::ZefRefs) -> ZefRefs<t>`

Shorthand for `filter[lambda ak: rae_type(ak) == t]`.
:::


### first / last

:::function `first(a::ZefRefs) -> ZefRef`
Extract the first entry of the given `ZefRefs`.
:::

:::function `last(a::ZefRefs) -> ZefRef`
Extract the last entry of the given `ZefRefs`.
:::


### only

:::function `only(a::ZefRefs) -> ZefRef`
Extract the only entry of the given `ZefRefs`, and throw an error if there is more than one entry.
:::


### only_or

TODO


### take

:::function `take[n::Int](a::ZefRefs) -> ZefRefs`
Extract the first `n` elements of `a`.
:::


### flatten

TODO: Maybe best to leave this until ZefTensors are in place


### intersect

:::function `intersect(a::ZefRefs,b::ZefRefs) -> ZefRefs`
Compute the intersection of `a` and `b`.

**Note:** `a` and `b` must be at the same time slice.
:::


### concatenate

TODO


### unique

:::function `unique(a::ZefRefs) -> ZefRefs`
Remove all duplicate entries from the given `ZefRefs`.
:::


### sort

:::function `sort[lt](a::ZefRefs) -> b::ZefRefs`
Sort `a` such that `lt(b[k],b[k+1])` is true for all `k`.
:::


## Time Travel

### now

:::function `now(a::ZefRef) -> ZefRef`

Most recent version of the timeless Zef object referenced by `a`.

**Example**

```python
g = Graph()
a = instantiate(AET.String,g)
a <= "Hello world"

a | value  # <- ERROR: a does not have a value at time of creation
a | now | value  # <- "Hello world"
```
:::


### tx

:::function `tx(a::ZefRef) -> ZefRef<TX>`
Extract the transaction from which `a` is viewed.
:::

:::function `tx(g::Graph) -> UZefRefs<TX>`
List all transactions on `g`.
:::


### instantiated / terminated

:::function `instantiated(a::UZefRef<TX>) -> ZefRefs`
List all entities which were instantiated in the given transaction.
:::


:::function `terminated(a::UZefRef<TX>) -> ZefRefs`
List all entities which were terminated in the given transaction.
:::


### value_assigned

:::function `value_assigned(a::UZefRef<TX>) -> ZefRefs`
List all atomic entities which were assigned a value in the given transaction.
:::

### instantiation_tx
### termination_tx
### value_assignment_txs


### time

### time_travel

### time_slice

### exists_at


## GQL

```python
schema_node = g | gql_schema
```
Returns the only schema node in the graph. Throws if there isn't exactly one instance of ET.GQL_Schema

```python
schema_node | gql_info
```
Returns a string summary of the gql types and resolvers.

```python
schema_node | gql_types
schema_node | gql_interfaces
schema_node | gql_scalars
schema_node | gql_enums
```
Returns a ZefRefs of the respective gql type attached to the schema_node.

```python
types_dict = schema_node | gql_types_dict
```
Returns a dictionary of gql type name to the ZefRef of the type.

```python
po_fields = types_dict['GQL_ProcessOrder'] | gql_fields_dict
```
Returns a dictionary of gql field name to the ZefRef of the field for all fields for a given gql_type.

```python
po_fields['GQL_EarliestOrderDueDate'] | gql_field_resolver
```
Returns a ZefRef of the resolver attached to a gql_field.  Throws if there isn't exactly one resolver.

## Various

### tag

```python
tag(g, 'selected-tag')
```

Tags Graph g with the 'selected-tag'

**Examples**

```python
tag(g, 'selected-tag', true)
```

Takes the tag by force if another graph is tagged with it.

```python
tag(g, 'selected-tag', adding=false) # true by default
```

Removes 'selected-tag' as tag from Graph g.


### lift
