---
id: add-data-manually
title: Add Data Manually
---

An immutable database would not be very interesting if it could never change. In which sense are ZefDB graphs immutable then? They are append only: once facts about the world have been added to a graph within a transaction, they can never be modified: information is added by accretion of facts. This is the clojure / Datomic philosophy of domain modeling: your database is an information management system and information is about facts. Facts never become invalidated, they are simply logs of events that happened in the world and mathematical truths that one may choose to reify. You should express your domain as a set of facts. A simple example would be to 

Working with an append-only database may seem like a strong restriction at first. It comes with significant benefits though: can rest assured that other threads / compute nodes can perform permissionless reads as much as they want. Not being able to mutate the database may seem like a strong restriction at first, but the freedom one gains by not having to coordinate reads in a distributed system feels like a superpower.

## Instantiating New Graphs
Let's have a look at some concrete examples of appending information to ZefDB graphs.
```python
g = Graph()             # purely local data structure
```
This instantiates a purely local graph. In contrast to most other databases, Zef blurs the line between the typical (lightweight) language-native data structures and a database. Creating a new database in Zef is very cheap (think of Python Dict / List). You can readily create them within the local context of a function.
```python
g = Graph(sync=True)
```

Suppose you have a local graph that you appended information to and only now decide that it is worth distributing and persisting. You can simply `sync` it at any later time using
```python
g | sync[True] | run
```
Again, `g | sync[True]` by itself simply returns an effect (pure data). Turning sync off is analogous, but you should be aware of some subtleties [...todo: link].

Without syncing, you will of course be able to pass around `g` between different functions and even safely access and concurrently read from multiple threads safely (more on this in the future). But it will not be published to the world outside of your process.

You can also think of syncing as the process that allows to switch between a purely "local database" (e.g. SQLite) vs. a "normal" database, which can be accessed by multiple clients / compute nodes.

## Starting Off
The graph `g` that was returned after instantiation is an eternal graph, i.e. it is not a slice at a given time, but the full accreting structure that contains all history. What does it contain? The graph's root node (of type BT.ROOT_NODE), a single transaction (of type BT.TRANSACTION_NODE) and possibly some meta-data (e.g. the zefhub user who instantiated the graph). Other than that, the very first graph slice which we can get hold of with
```python
g | All[tx] | first         # returns a GraphSlice: the state at a given point in time
```

## Basic Data Types
The data model [TODO: reference...] underlying Zef graphs is somewhat different from all other databases. In a nutshell: there are three elementary building blocks we can use to construct a graph:
1. **Entities**: think of these as "domain objects" / "documents" / aggregate roots. They have no internal structure, since one of the core zef principles is to choose associative ontologies over hierarchical taxonomies. Every instance of an entity always has a EntityType determined by your domain model, e.g. `ET.Customer`, as well as a uid. Think of an entity as representing something / some useful abstraction with an identity in the real world. It forms a node in the graph whose identity persists over some interval of time.

2. **Atomic Entity** Similar to an entity, but it can also take on a value. For instance a customer's surname could be represented by an AE (atomic entity) of type `AET.String`. Think of these as counterparts to the values of fields on objects / document DBs or columns in relational databases. However, a field has its own identity and uid. In Zef we do not see a person as an aggregate of fields. We prefer to model the domain as a set of very granular entities/atomic entities with relations between them. Also, the values assigned to AEs may change over time, e.g. a customer's surname may take on different string values over time. Hence, an AE can also be seen as a stream / observable (or persisted log thereof) containing items of its type. Prefer AEs of simple scalar values over composite types.

3. **Relations** Edges on the high level graph. Every relation instance also has a RelationType e.g. `RT.FriendOf` and an identity characterized by its uid. Also, every relation has a source and a target of type
    - Entity
    - Atomic Entity
    - Relation
    - Transaction
    - Graph Root
If a relation exists, the source/target must both exist as well. Hence, if either the source or target are terminated in a transaction, all connected relations will automatically be terminated in the same transaction. Relations are also immutable: once instantiated, they can never be reconnected to a different source/target.

Since we often want to refer to the combination of one these three elementary types, we define the acronym of a "RAE" (Relation / AtomicEntity / Entity).

In addition to RAEs, Transactions (TXs) are also a first class citizen (nodes on the graph), but they are automatically created.


## Appending Information

:::note Historic Note
In the first version of zefDB, we had a much more imperative API. `instantiate(...)`, `assign_value(...)`, `terminate(...)` were functions that eagerly modified the graph. As we used zefDB to build out the foundational data layer, UIs and coordinating most parts of our distributed system, we moved to an ever more declarative and lazy model over time.
This may seem cumbersome at first, but the advantages pay off very quickly on various fronts: referential transparency (how did the system get into this state?!?), thread safety, testablity, managing side effects, ability to add custom middleware layers. At the end of the day, a declarative structure scales much more favorably as a system and its requirements grow. A larger part of your business logic can be written as pure functions that take simple data structures and return simple data structures.
:::

Suppose we want to model a chess game.


### Instantiating RAEs
```python
my_eff = ET.Queen | g             # piping into g: we want to merge this ET into g
run(my_eff)                       # do the transaction
```

For relations
```python
[ 
  (z1, RT.Bar, z2),               # new relation between existing RAEs
  (ET.Foo, RT.Bar, z2),           # types can be passed as source/target: instances automatically created
  (ET.Foo, RT.Bar, "Hello!"),     # values can be passed: instantiates AET and assigs
] | transact[g]
```




### Terminating RAEs
```python
[ 
  terminate[z1],
] | transact[g]
```
For relations, `terminate` is only called on the relation's ZefRef itself, not on the triple.

### Assigning Values
```python
[ 
  z_float <= 42.0,          # assign a value to an existing RAE of type AET.Float
  AET.String <= "Hello!"    # instantiate a new RAE and assign a value
] | transact[g]
```

## Accessing Newly Created RAEs
Now we know how write and update data on a graph. Often we want to access this new data and possibly keep on processing that. Think of the graph as a big ledger, where facts are carved in stone. How do we talk about these facts? Copying them out as values may be problematic, as they may also relate to many other facts and 




## Merging RAEs from other Graphs

```python
[z1, z2] | transact[g]      # merge in z1 and z2
```
We can understand this as the intent *"I want you to know about these two RAEs z1 and z2"*. Note that the GraphDelta is unaware of the graph that it will be "applied to". If the target graph already know about `z1` and `z2` (an instance of the respective lineage exists), this will result in a no-op (idempotency).

For AETs the additional option to also include a specific value assignment in the same graph delta arises. We can control this via the type:
1. EZefRef: no value assignment
1. ZefRef: value assignment using the value in the given reference frame
1. Explicit reference assignment (overrides 2.)
```python
[
  z1 | to_ezefref,      # no value assignment
  z2,                   # value(2) used as value assignment
  z3 <= 42,             # merge & explicit value assignment
] | transact[g]
```


## Schema Changes
Similar semantics apply to the delegates to modify a graphs schema.
```python
[ 
  delegate[ET.Person],
  delegate[(ET.Person, RT.LastName, AET.String)],
] | transact[g]
```
In contrast to instances, delegates are singletons: `delegate[ET.Foo]` refers to the set of all ET.Foo that have ever existed and will ever exist. Hence, we can think of a types delegate to be a singleton across graphs. Hence, it does not make sense to allow delegates to be terminated, since that has far reaching implications in the context of streams/observables (once an observable calls `on_complete`, it can never be revived).

But thinking of a graph's schema as pure data which is also fully versioned within the epochal model is very useful. To bridge this divide, we introduce the concept of *retirement* for delegates. A retired delegate is no longer active in a schema (and acts as if it were not present), but it can be taken out of retirement in the future if ever needed again for the schema.

We keep the same semantics as for instances though:
```python
[ 
  terminate[delegate[(ET.Person, RT.LastName, AET.String)]]
] | transact[g]
```
retires the schema node. The usual instantiation syntax
```python
[ 
  delegate[(ET.Person, RT.LastName, AET.String)]
] | transact[g]
```
reactivates it from retirement if it is already present on a graph (rather than instantiating a new delegate).







## Hostage Taking
Automatically terminate the source/target RAE taken hostage when the relation is terminated. Hostage taking lives at the boundary between the relation and its source/target.

Shared hostage: there may be multiple taking a RAE weak hostage. Only terminate the RAE if the last hostage taker is terminated (analogous to C++ std::shared_ptr).

This property has to be set at the time of instantiation and cannot be modified afterwards.
```python
actions = [
  (ET.Dog, RT.Name, AET.String[hostage]['Rufus'] )  
  (ET.Person[shared_hostage], RT.Owns, ET.Cat)
]
```

The above example applies to a single instance.





## Shorthand Notation


It is also possible to not explicitly declare a GraphDelta and use the syntax
```python
z = ET.Foo | g | run
```
to instantiate an entity. The same notation extends to termination, merging, value assignment, etc.
Also notice the difference in the return value: this syntax immediately returns the ZefRefs in a structural form isomorphic to the form of the input:
```python
foo, bar = [ET.Foo, ET.Bar] | g | run
```
Relations can be created by passing in triples
```python
foo, bar, (qux, z_rel, z_val) = [ET.Foo, ET.Bar, (ET.Qux, RT.Name, "qux")] | g | run
```
and nesting is  also possible.




## Accessing Existing Graphs

There are three different ways to mark and retrieve graphs.
1. Each graph is automatically assigned a uid upon instantiation which can never be changed. The uid can be accessed via `my_graph_uid = uid(g)` and any graph that is synced with zefhub can be accessed and loaded using `g = Graph(my_graph_uid)` if the user access right allow for it.

2. Graphs themselves can be tagged with the tag names chosen by the user. 
  ```python
  g | tag['my favorite graph'] | z_some_project          # returns an effect
  g | tag[allow_steal]['my favorite graph'] | user_graph | run
  ```
  Since tagging changes the state of the system, it is done via the ZefFX system. We can think of the zefhub project `z_some_project` as a namespace within which tags can be assigned. Similarly, a Zefhub user's graph, as well as the local process graph can act as such namespaces. 
  Retrieving graphs from tags:
  ```python
  tag['my favorite graph'] | z_some_project | run                # returns the tagged graph
  g | tag[allow_steal]['my favorite graph'] | user_graph  
  ```
3. Graphs themselves are values (think of them as wrapped pointers to the underlying data buffer) and can therefore be treated like other zef values. They can be used as elements of lists, sent over streams or stored as values in atomic entities of other graphs.


