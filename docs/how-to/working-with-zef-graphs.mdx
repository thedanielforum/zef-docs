---
id: working-with-zef-graphs
title: Working with zef Graphs
---



```python
g = Graph(sync=True)
```

This will automatically sync changes with zefhub and persist all changes.


```python
g | tag['my-new-graph'] | run     # will be primary instance if newly created
```

In a different process / different computer we can retrieve this graph with the entire history

```python
g = Graph('my-new-graph')         # won't be primary instance
```

```python
rufus = ET.Dog | transact[g]
type(rufus)             # => ZefRef at the time slice of the instantiation
info(rufus)             # print info to repl
```


### Entry points for graphs
In contrast to trees, graphs don't have structurally defined roots and no unique 'entry point'. You can think of graph traversals very much like a REST API. If you already know the entity you are interested in, you can navigate along from there. Otherwise there are various entry points:
* listing all RAEs on a graph `g | all` for all EZefRefs on the eternal graph or `g | all[ET.Person]` to restrict to a given type
* `g | graph_slice['26. Sep 2021 14:00 +0800'] | all[ET.Person]` to obtain all ZefRefs in a given graph slice

### Tagging RAEs
We may also tag specific RAEs on the graph 


```python
# rufus is a ZefRef to an ET.Dog
rufus | tag['the best boy'] | transact[g]
```
Let us quickly discuss the types: `tag` is a zefOp into which we curry the tag label of our choice into. This returns a new zefOP `tag['the best boy']` which contains this information (zefops never mutate, i.e. `tag` remains unaffected). 
`rufus | tag['the best boy']` returns an expression that reflects the intent of tagging the RAE `rufus` with the given tag label, but it does not do anything yet. It is also unaware of the graph it may be used on. Only when piped into the `transact[g]` is the graph actually modified.


Let's suppose some RAE on the graph is already tagged using this tag name. Well, we could either a) allow the tag to be stolen by default or b) fail and not perform the transaction. It could lead to fairly subtle bug if we quietly stole the tag, especially if the command came from a remote user where race conditions may be involved (suppose someone else assigned the tag between their checking of whether the tag existed and their tx arriving) or if they were simply not aware of what their transaction may be breaking. Therefore, unless the user explicitly specifies 
```python
rufus | tag['the best boy'][allow_stealing] | transact[g]
```
the default behavior will be that the transaction request fails.


To remove a tag, we can simply make use of the `remove` zefop.
```python
remove[tag['the best boy']] | transact[g]

# only have the tx succeed if this tag is assigned to `rufus`
remove[tag['the best boy'][rufus]] | transact[g]        
```



