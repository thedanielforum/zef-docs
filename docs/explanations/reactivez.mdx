---
id: reactivez
title: ReactiveZ
---






# Streams

```python
# create a new concrete stream
my_stream = Effect({'type': FX.Stream.CreatePushableStream }) | run
```

```python
# data flows from left to right: push a message into our concrete stream
'goeie m√¥re' | push[my_stream] | run
```

But nothing happens, because nothing is listening to the stream.
Let's set up an (impure) callback in background: run 'print' on each item coming through
```python
my_stream | subscribe[print]      
'wat pomp?' | delay[1.2*units.seconds] | push[my_stream]     # now we see it printed with a delay
```






```python
# we can also instantiate a concrete stream on a zefhub project.
my_stream2 = Effect({'type': FX.Stream.CreatePushableStream }) | run[my_zefhub_project]
```
A ZefRef (living on the project graph) will be returned. Just like a graph having a single write head, a stream also has a single authoritative "write head" that can push values in. When we call
```python
'hello from my notebook!' | push[my_stream2] | run
```
the effect will be forwarded to the stream's write head before actually being published. This ensures that messages within a stream are strictly serializable, i.e. a unique order is well defined.

Multiple listeners across processes and machines can subscribe to a stream and zef (and zefhub when running in distributed mode) will handle all the coordination behind the scenes.








# GraphQL Schemas

Suppose we have some graph and we want to others to interact with it via a graphQL API.
We could manually declare a schema, but zef also provides utilities to automatically generate a graphQL schema from a graph's schema.
Every graph automatically builds up a schema along the way, as you throw data at it (you may not have noticed). A graphs schema is simply the set of all delegate RAEs at a given time. The schema itself, like all data on the high level graph, is fully versioned and defined within each GraphSlice.
```python
my_api = (
g                     
| now                   # we need a graph slice
| schema                # returns all delegates (the schema) as a List[ZefRef[delegate[RAE]]]
| generate_gql_api      # returns a GraphDelta to create a GQL schema and API from the graph schema
| g                     # create an effect: apply GraphDelta to this graph
| run                   # executes and returns a dict
| get['api'] 
)
```
Let us explore the API by launching the GraphQL playground locally. We can do this via the effects system (zefFX)
```python
Effect({
        "type": FX.GraphQL.StartGraphQLPlayground,
        "api_zefref": my_api,
        "port": 5000,
}) | run

```





# Navigating a Graph

### Given a TX, show me what happened

```python
z_tx = g | now | to_tx

# what was instantiated during this tx?
instantiated_raes_zr  = z_tx | instantiated                 # returns a List[ZefRef[RAE]]
instantiated_raes_ezr = z_tx | to_ezefref | instantiated    # returns a List[EZefRef[RAE]]

# what was terminated during this tx?
terminated_raes_zr  = z_tx | terminated                     # returns a List[ZefRef[RAE]]
terminated_raes_ezr = z_tx | to_ezefref | terminated        # returns a List[EZefRef[RAE]]

# find all AEs to which a new value was assigned in this tx
val_assigned_raes_zr  = z_tx | value_assigned               # returns a List[ZefRef[RAE]]
val_assigned_raes_ezr = z_tx | value_assigned               # returns a List[EZefRef[RAE]]
```

There are two more operators:
```python
z | affected      # all RAEs that were affected in any way
z | merged        # 'merged' is considered a subset of 'instantiated'
```




### Given a ZefRef to a RAE `z`, how can I see what happened in the past?
```python
z | instantiated        # returns a ZefRef[TX]
z | terminated          # returns a Union[ZefRef[TX], Nil]
z | value_assigned      # returns a List[ZefRef[TX]]
```

All returned values keep the same reference frame as z.
For example, `z | frame == z | instantiated | frame` is always true.

We can use exactly the same operators on the eternalist counterpart acting on a EZefRef `z_ezr`
```python
z_ezr | instantiated        # returns a EZefRef[TX]
z_ezr | terminated          # returns a Union[EZefRef[TX], Nil]
z_ezr | value_assigned      # returns a List[EZefRef[TX]]
```

Neither the input nor the output have a reference frame. Implicitly, everything will be answered according to the latest version we have of the graph.
This also implies that these operators (and transitively any functions making use of these operators on EZefRefs) are not zef pure: If we allow the underlying graph to be appended to, the resulting function output may be different if we were to rerun this in the future.


