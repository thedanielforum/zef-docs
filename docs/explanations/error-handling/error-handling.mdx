---
id: error-handling
title: Error Handling
---

Using exceptions to manage control flow comes with many drawbacks. These are only exacerbated when combined with asynchronous programming and distributed systems.
In Zef we eschew using exceptions for any anticipated behavior of our program and prefer using Errors instead.
An `Error` is a bultin value type in Zef. Like other values, it is contiguous in memory, can be passed around as function input and output types, be sent over the wire, assigned to AETs etc.

Functions should also be honest about their behavior, e.g. within the type signature.
```python
def square_root(x: Float) -> Float:        # ðŸ¤¥  
    return x**0.5   
```
This type signature is not honest about what can happen when the function is called. For negative numbers, this will not return anything. It will throw an exception, i.e. our programs control flow did not go via the return type at all. Oh dear.
At this point one often sees code cluttered with `try` `except` blocks. Type checkers like MyPy can also not reason about the control flow at this point, because Python does not allow functions to be marked noexcept.

In Zef we take a different approach. All functions concerned with higher level business logic should not throw. Ever.
What to do instead? The answer is not surprising. We just stick with the principle that most of our business logic, if possible, should be expressed in terms of pure functions. These take values and return values. That is all they can do.
If our `square_root` cannot return a Float, it should be honest about it. Also in its type signature. It's up to us how we choose to model this case. Three reasonable alternatives are
```python
def square_root(x: Float) -> Either[Float][Nil]:
    return x**0.5 if x >= 0 else nil


def square_root2(x: Float) -> Either[Float][Error]:
    return x**0.5 if x >= 0 else Error('cannot take the square root of a negative number')
```
![](and-now-for-something-completely-different.png "Wait but ...")


```python
positive_float = And[
    is_a[Float],
    larger_than_or_equal[0.0]
]

def square_root(x: positive_float) -> positive_float:
    return x**0.5   
```

## Conclusion
Exceptions are a low level primitive that should not be used for handling control flow of logic our high level programs.

